/*
* Copyright 2015 SpinalCom - www.spinalcom.com
*
* This file is part of SpinalCore.
*
* Please read all of the following terms and conditions of the Free Software
* license Agreement ("Agreement") carefully.
*
* This Agreement is a legally binding contract between the Licensee (as defined
* below) and SpinalCom that sets forth the terms and conditions that govern
* your use of the Program. By installing and/or using the Program, you agree to
* abide by all the terms and conditions stated or referenced herein.
*
* If you do not agree to abide by these terms and conditions, do not
* demonstrate your acceptance and do not install or use the Program.
*
* You should have received a copy of the license along with this file. If not,
* see <http://resources.spinalcom.com/licenses.pdf>.
*/

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Generated by CoffeeScript 2.3.2
(function () {
  // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  var BindProcess,
      Bool,
      Choice,
      ConstOrNotModel,
      ConstrainedVal,
      Directory,
      File,
      FileSystem,
      Lst,
      Model,
      Obj,
      Path,
      Process,
      Ptr,
      RightSetList,
      RightsItem,
      SessionModel,
      Str,
      TiffFile,
      TypedArray,
      TypedArray_Float32,
      TypedArray_Float64,
      TypedArray_Int32,
      User,
      UserRight,
      Val,
      Vec,
      _index_current_popup,
      root,
      spinal_new_popup,
      url,
      indexOf = [].indexOf;

  url = require('url');
  root = typeof _root_obj === "undefined" ? global : window;

  if (typeof root.spinalCore !== 'undefined') {
    module.exports = root.spinalCore;
    return;
  }

  root.spinalCore = function () {
    var spinalCore =
    /*#__PURE__*/
    function () {
      function spinalCore() {
        _classCallCheck(this, spinalCore);
      }

      _createClass(spinalCore, null, [{
        key: "connect",
        value: function connect(options) {
          var auth;

          if (typeof options === 'string') {
            options = url.parse(options);
          }

          if (options.path.slice(-1)[0] !== "/") {
            options.path += "/";
          }

          FileSystem._home_dir = options.path;
          FileSystem._url = options.hostname;
          FileSystem._port = options.port;

          if (options.auth !== null) {
            auth = options.auth.split(":");
            FileSystem._userid = auth[0];

            if (auth.length > 1) {
              FileSystem._password = auth[1];
            }
          } else {
            // set default user id
            FileSystem._userid = 644;
            FileSystem._password = "";
          }

          return new FileSystem();
        } // stores a model in the file system

      }, {
        key: "store",
        value: function store(fs, model, path, callback_success, callback_error) {
          var file_name, lst;

          if (typeof callback_error === "undefined") {
            callback_error = function callback_error() {
              return console.log("Model could not be stored. You can pass a callback to handle this error.");
            };
          } // Parse path


          lst = path.split("/");
          file_name = lst.pop();

          if (lst[0] === "") {
            lst.splice(0, 1);
          }

          path = lst.join("/"); // Absolute paths are not allowed

          return fs.load_or_make_dir(FileSystem._home_dir + path, function (dir, err) {
            var file;

            if (err) {
              return callback_error();
            } else {
              file = dir.detect(function (x) {
                return x.name.get() === file_name;
              });

              if (file != null) {
                dir.remove(file);
              }

              dir.add_file(file_name, model, {
                model_type: "Model"
              });
              return callback_success();
            }
          });
        } // register models, required when ussing modules require/import

      }, {
        key: "register_models",
        value: function register_models(modelList) {
          var key, len, m, q, results, results1, value;

          if (modelList) {
            if (modelList instanceof Function) {
              // function
              spinalCore._register_models_check(modelList);
            }

            if (modelList instanceof Array) {
              // array
              results = [];

              for (q = 0, len = modelList.length; q < len; q++) {
                m = modelList[q];

                if (m instanceof Function) {
                  results.push(spinalCore._register_models_check(m)); // object
                } else {
                  results.push(void 0);
                }
              }

              return results;
            } else {
              results1 = [];

              for (key in modelList) {
                value = modelList[key];

                if (value instanceof Function) {
                  results1.push(spinalCore._register_models_check(value));
                } else {
                  results1.push(void 0);
                }
              }

              return results1;
            }
          }
        }
      }, {
        key: "_register_models_check",
        value: function _register_models_check(func) {
          if (typeof spinalCore._def[func.name] !== 'undefined' && spinalCore._def[func.name] !== func) {
            console.warn("trying to register \"".concat(func.name, "\" Model but was already defined"));
            console.warn("old =", spinalCore._def[func.name]);
            console.warn("new =", func);
          }

          return spinalCore._def[func.name] = func;
        } // loads a model from the file system

      }, {
        key: "load",
        value: function load(fs, path, callback_success, callback_error) {
          var file_name, lst;

          if (typeof callback_error === "undefined") {
            callback_error = function callback_error() {
              return console.log("Model could not be loaded. You can pass a callback to handle this error.");
            };
          } // Parse path


          lst = path.split("/");
          file_name = lst.pop();

          if (lst[0] === "") {
            lst.splice(0, 1);
          }

          path = lst.join("/"); // Absolute paths are not allowed

          return fs.load_or_make_dir(FileSystem._home_dir + path, function (current_dir, err) {
            var file;

            if (err) {
              return callback_error();
            } else {
              file = current_dir.detect(function (x) {
                return x.name.get() === file_name;
              });

              if (file != null) {
                return file.load(function (data, err) {
                  if (err) {
                    return callback_error();
                  } else {
                    return callback_success(data, err);
                  }
                });
              } else {
                return callback_error();
              }
            }
          });
        } // loads all the models of a specific type

      }, {
        key: "load_type",
        value: function load_type(fs, type, callback_success, callback_error) {
          if (typeof callback_error === "undefined") {
            callback_error = function callback_error() {
              return console.log("Model of this type could not be loaded. " + "You can pass a callback to handle this error.");
            };
          }

          return fs.load_type(type, function (data, err) {
            if (err) {
              return callback_error();
            } else {
              return callback_success(data, err);
            }
          });
        }
      }, {
        key: "load_right",
        value: function load_right(fs, ptr, callback_success, callback_error) {
          if (typeof callback_error === "undefined") {
            callback_error = function callback_error() {
              return console.log("Model Right could not be loaded." + " You can pass a callback to handle this error.");
            };
          }

          return fs.load_right(ptr, function (data, err) {
            if (err) {
              return callback_error();
            } else {
              return callback_success(data, err);
            }
          });
        }
      }, {
        key: "share_model",
        value: function share_model(fs, ptr, file_name, right_flag, targetName) {
          return fs.share_model(ptr, file_name, right_flag, targetName);
        } // "static" method: extend one object as a class, using the same 'class' concept as coffeescript

      }, {
        key: "extend",
        value: function extend(child, parent) {
          var child_name, ctor, key, value;

          for (key in parent) {
            value = parent[key];
            child[key] = value;
          }

          ctor = function ctor() {
            this.constructor = child;
          };

          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;

          child.super = function () {
            var args = [];

            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }

            child.__super__.constructor.apply(arguments[0], args); // using embedded javascript because the word 'super' is reserved

          };

          root = typeof global !== "undefined" && global !== null ? global : window;
          child_name = /^(function|class)\s+([\w\$]+)\s*\(/.exec(child.toString())[1];
          return root[child_name] = child;
        }
      }]);

      return spinalCore;
    }();

    ;
    spinalCore._def = {};
    spinalCore.right_flag = {
      AD: 1,
      WR: 2,
      RD: 4
    };
    return spinalCore;
  }.call(this);

  module.exports = spinalCore; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // scalar

  root = typeof _root_obj === "undefined" ? global : window;

  root.ModelProcessManager = function () {
    var ModelProcessManager =
    /*#__PURE__*/
    function () {
      function ModelProcessManager() {
        _classCallCheck(this, ModelProcessManager);
      }

      _createClass(ModelProcessManager, null, [{
        key: "new_from_state",
        // modify state according to str. str can be the result of a previous @get_state
        value: function new_from_state(str) {
          var l, len, lst, map, mid, q, s;
          map = {};
          lst = str.split("\n");
          mid = lst.shift();

          for (q = 0, len = lst.length; q < len; q++) {
            l = lst[q];

            if (!l.length) {
              continue;
            }

            s = l.split(" ");
            map[s[0]] = {
              type: s[1],
              data: s[2],
              buff: void 0
            };
          } // fill / update this with data in map[ mid ]


          eval("var __new__ = new ".concat(map[mid].type, ";"));

          __new__._set_state(map[mid].data, map);

          return __new__;
        }
      }, {
        key: "load",
        value: function load(filename, func) {
          if (!ModelProcessManager.synchronizer) {
            ModelProcessManager._synchro = new Synchronizer();
          }

          return ModelProcessManager._synchro.load(filename, func);
        } // If v is a Model, return v. Else, return a Model of guessed right type

      }, {
        key: "conv",
        value: function conv(v) {
          if (v instanceof Model) {
            return v;
          }

          if (v instanceof Array) {
            return new Lst(v);
          }

          if (typeof v === "string") {
            return new Str(v);
          }

          if (typeof v === "number") {
            return new Val(v);
          }

          if (typeof v === "boolean") {
            return new Bool(v);
          }

          if (v instanceof Object) {
            return new Model(v);
          }

          return new Obj(v);
        } // return the type of obj

      }, {
        key: "get_object_class",
        value: function get_object_class(obj) {
          var arr;

          if (obj && obj.constructor && obj.constructor.name) {
            return obj.constructor.name;
          }

          if (obj && obj.constructor && obj.constructor.toString) {
            arr = obj.constructor.toString().match(/function\s*(\w+)/);

            if (!arr) {
              arr = obj.constructor.toString().match(/class\s*(\w+)/);
            }

            if (arr && arr.length === 2) {
              return arr[1];
            }
          }
        }
      }, {
        key: "_get_attribute_names",
        value: function _get_attribute_names(m) {
          var key, results, val;

          if (m instanceof Model) {
            return m._attribute_names;
          } else {
            results = [];

            for (key in m) {
              val = m[key];
              results.push(key);
            }

            return results;
          }
        } // create a Model using a line of get_state (using .type, .data, ...)

      }, {
        key: "_new_model_from_state",
        value: function _new_model_from_state(mid, map) {
          var info;
          info = map[mid];
          eval("info.buff = new ".concat(info.type, ";"));

          info.buff._set_state(info.data, map);

          return info.buff;
        } // say that something will need a call
        // to ModelProcessManager._sync_processes during the next round

      }, {
        key: "_need_sync_processes",
        value: function _need_sync_processes() {
          if (ModelProcessManager._timeout == null) {
            return ModelProcessManager._timeout = setTimeout(ModelProcessManager._sync_processes, 1);
          }
        } // the function that is called after a very short timeout,
        // when at least one object has been modified

      }, {
        key: "_sync_processes",
        value: function _sync_processes() {
          var id, len, model, process, processes, q, ref, ref1, ref2;
          processes = {};
          ref = ModelProcessManager._modlist;

          for (id in ref) {
            model = ref[id];
            ref1 = model._processes;

            for (q = 0, len = ref1.length; q < len; q++) {
              process = ref1[q];
              processes[process.process_id] = {
                value: process,
                force: false
              };
            }
          }

          ref2 = ModelProcessManager._n_processes;

          for (id in ref2) {
            process = ref2[id];
            processes[id] = {
              value: process,
              force: true
            };
          }

          ModelProcessManager._timeout = void 0;
          ModelProcessManager._modlist = {};
          ModelProcessManager._n_processes = {};
          ModelProcessManager._counter += 2;

          for (id in processes) {
            process = processes[id];
            ModelProcessManager._force_m = process.force;
            process.value.onchange();
          }

          return ModelProcessManager._force_m = false;
        }
      }]);

      return ModelProcessManager;
    }();

    ; // nb "change rounds" since the beginning ( * 2 to differenciate direct and indirect changes )

    ModelProcessManager._counter = 0; // changed models (current round)

    ModelProcessManager._modlist = {}; // new processes (that will need a first onchange call in "force" mode)

    ModelProcessManager._n_processes = {}; // current model id (used to create new ids)

    ModelProcessManager._cur_mid = 0; // current process id (used to create new ids)

    ModelProcessManager._cur_process_id = 0; // timer used to create a new "round"

    ModelProcessManager._timeout = void 0; // if _force_m == true, every has_been_modified function will return true

    ModelProcessManager._force_m = false; // synchronizer (link to the server that will store files)

    ModelProcessManager._synchro = void 0;
    return ModelProcessManager;
  }.call(this); // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // scalar


  root = typeof _root_obj === "undefined" ? global : window;

  root.SpinalUserManager =
  /*#__PURE__*/
  function () {
    function SpinalUserManager() {
      _classCallCheck(this, SpinalUserManager);
    }

    _createClass(SpinalUserManager, null, [{
      key: "get_user_id",
      value: function get_user_id(options, user_name, password, success_callback) {
        var error_callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        var get_cmd; // Access: /get_user_id?u=<user>&p=<password>

        get_cmd = '/get_user_id?u=' + user_name + '&p=' + password;
        return this.send_xhr(options, get_cmd, function (response) {
          if (parseInt(response) === -1) {
            return SpinalUserManager._if_error(error_callback, 'get_user_id', response);
          } else {
            return success_callback(response);
          }
        }, function (status) {
          return SpinalUserManager._if_error(error_callback, 'get_user_id', status);
        });
      }
    }, {
      key: "get_admin_id",
      value: function get_admin_id(options, admin_name, password, success_callback) {
        var error_callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        var get_cmd; // Access: /get_user_id?u=<user>&p=<password>

        get_cmd = '/get_admin_id?u=' + admin_name + '&p=' + password;
        return this.send_xhr(options, get_cmd, function (response) {
          if (parseInt(response) === -1) {
            return SpinalUserManager._if_error(error_callback, 'get_admin_id', response);
          } else {
            return success_callback(response);
          }
        }, function (status) {
          return SpinalUserManager._if_error(error_callback, 'get_admin_id', status);
        });
      }
    }, {
      key: "new_account",
      value: function new_account(options, user_name, password, success_callback) {
        var error_callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        var get_cmd; // Access: /get_new_account?e=<user>&p=<password>&cp=<confirm_password>

        get_cmd = '/get_new_account?e=' + user_name + '&p=' + password + '&cp=' + password;
        return this.send_xhr(options, get_cmd, function (response) {
          if (parseInt(response) === -1) {
            return SpinalUserManager._if_error(error_callback, 'get_new_account', status);
          } else {
            return success_callback(response);
          }
        }, function (status) {
          return SpinalUserManager._if_error(error_callback, 'get_new_account', status);
        });
      }
    }, {
      key: "change_password",
      value: function change_password(options, user_id, password, new_password, success_callback) {
        var error_callback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
        var get_cmd; // Access: /get_change_user_password?e=<user>&op=<old_pass>&np=<newpass>&cp=<confim_pass>

        get_cmd = '/get_change_user_password?e=' + user_id + '&op=' + password + '&np=' + new_password + '&cp=' + new_password;
        return this.send_xhr(options, get_cmd, function (response) {
          if (parseInt(response) === -1) {
            return SpinalUserManager._if_error(error_callback, 'get_change_user_password', status);
          } else {
            return success_callback(response);
          }
        }, function (status) {
          return SpinalUserManager._if_error(error_callback, 'get_change_user_password', status);
        });
      }
    }, {
      key: "delete_account",
      value: function delete_account(options, user_id, password, success_callback) {
        var error_callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        var get_cmd; // Access: /get_delete_account?e=<user>&i=<id>&p=<password>

        get_cmd = '/get_delete_account?e=' + user_name + '&i=' + user_id + '&p=' + password;
        return this.send_xhr(options, get_cmd, function (response) {
          if (parseInt(response) === -1) {
            return SpinalUserManager._if_error(error_callback, 'get_delete_account', status);
          } else {
            return success_callback(response);
          }
        }, function (status) {
          return SpinalUserManager._if_error(error_callback, 'get_delete_account', status);
        });
      }
    }, {
      key: "change_password_by_admin",
      value: function change_password_by_admin(options, username, password, admin_id, admin_password, success_callback) {
        var error_callback = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
        var get_cmd; // Access: ?u=<username>&np=<newpass>&a=<admin_id>&ap=<adminPass>
        // admin == 644(root) or 168(admin)

        get_cmd = '/get_change_user_password_by_admin?u=' + username + '&np=' + password + '&a=' + admin_id + '&ap=' + admin_password;
        return this.send_xhr(options, get_cmd, function (response) {
          if (parseInt(response) === -1) {
            return SpinalUserManager._if_error(error_callback, 'get_change_user_password_by_admin', status);
          } else {
            return success_callback(response);
          }
        }, function (status) {
          return SpinalUserManager._if_error(error_callback, 'get_change_user_password_by_admin', status);
        });
      }
    }, {
      key: "delete_account_by_admin",
      value: function delete_account_by_admin(options, username, admin_id, admin_password, success_callback) {
        var error_callback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
        var get_cmd; // Access: /get_delete_account_by_admin?u=<username>&a=<admin_id>&ap=<adminPassword>
        // admin == 644(root) or 168(admin)

        get_cmd = '/get_delete_account_by_admin?u=' + username + '&a=' + admin_id + '&ap=' + admin_password;
        return this.send_xhr(options, get_cmd, function (response) {
          if (parseInt(response) === -1) {
            return SpinalUserManager._if_error(error_callback, 'get_delete_account_by_admin', status);
          } else {
            return success_callback(response);
          }
        }, function (status) {
          return SpinalUserManager._if_error(error_callback, 'get_delete_account_by_admin', status);
        });
      }
    }, {
      key: "change_account_rights_by_admin",
      value: function change_account_rights_by_admin(options, username, right, admin_id, admin_password, success_callback) {
        var error_callback = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
        var get_cmd; // Access: ?u=<username>&ri=<rights>&a=<admin_id>&ap=<adminPass>
        // admin == 644(root) or 168(admin)

        get_cmd = '/get_change_account_rights_by_admin?u=' + username + '&ri=' + right + '&a=' + admin_id + '&ap=' + admin_password;
        return this.send_xhr(options, get_cmd, function (response) {
          if (parseInt(response) === -1) {
            return SpinalUserManager._if_error(error_callback, 'get_change_account_rights_by_admin', status);
          } else {
            return success_callback(response);
          }
        }, function (status) {
          return SpinalUserManager._if_error(error_callback, 'get_change_account_rights_by_admin', status);
        });
      }
    }, {
      key: "send_xhr",
      value: function send_xhr(options, get_cmd, success_callback, error_callback) {
        var path, xhr_object;
        path = "";

        if (typeof options === 'string') {
          options = url.parse(options);
        }

        FileSystem._url = options.hostname;
        FileSystem._port = options.port;

        if (FileSystem.CONNECTOR_TYPE === "Node" || FileSystem.is_cordova) {
          if (FileSystem._port) {
            path = "http://" + FileSystem._url + ":" + FileSystem._port + get_cmd;
          } else {
            path = "http://" + FileSystem._url + get_cmd;
          }
        } else if (FileSystem.CONNECTOR_TYPE === "Browser") {
          path = get_cmd;
        }

        xhr_object = FileSystem._my_xml_http_request();
        xhr_object.open('GET', path, true);

        xhr_object.onreadystatechange = function () {
          if (this.readyState === 4 && this.status === 200) {
            return success_callback(this.responseText);
          } else if (this.readyState === 4) {
            return error_callback(this.status);
          }
        };

        return xhr_object.send();
      }
    }, {
      key: "_if_error",
      value: function _if_error(error_callback, fun, response) {
        if (error_callback !== null) {
          return error_callback(response);
        } else {
          return console.log('Error on ' + fun + ' and the error_callback was not set.');
        }
      }
    }]);

    return SpinalUserManager;
  }(); // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.


  root = typeof _root_obj === "undefined" ? global : window;

  Model =
  /*#__PURE__*/
  function () {
    function Model(attr) {
      _classCallCheck(this, Model);

      // registered attribute names (in declaration order)
      this._attribute_names = []; // id of the model

      this.model_id = ModelProcessManager._cur_mid;
      ModelProcessManager._cur_mid += 1; // synchronized processes

      this._processes = []; // parent models (depending on this)

      this._parents = []; // "date" of previous change. We start at + 2 because
      // we consider that an initialisation is a modification.

      this._date_last_modification = ModelProcessManager._counter + 2; // init

      if (attr != null) {
        this._set(attr);
      }
    }

    _createClass(Model, [{
      key: "destructor",
      value: function destructor() {} // return true if this (or a child of this) has changed since the previous synchronisation

    }, {
      key: "has_been_modified",
      value: function has_been_modified() {
        return this._date_last_modification > ModelProcessManager._counter - 2 || ModelProcessManager._force_m;
      } // return true if this has changed since previous synchronisation due to
      //  a direct modification (not from a child one)

    }, {
      key: "has_been_directly_modified",
      value: function has_been_directly_modified() {
        return this._date_last_modification > ModelProcessManager._counter - 1 || ModelProcessManager._force_m;
      } // if this has been modified during the preceding round, f will be called
      // If f is a process:
      //  process.onchange will be called each time this (or a child of this) will be modified.
      //  process.destructor will be called if this is destroyed.
      //  ...
      //  can be seen as a bind with an object
      // onchange_construction true means that onchange will be automatically called after the bind

    }, {
      key: "bind",
      value: function bind(f) {
        var onchange_construction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (f instanceof Process) {
          this._processes.push(f);

          f._models.push(this);

          if (onchange_construction) {
            ModelProcessManager._n_processes[f.process_id] = f;
            return ModelProcessManager._need_sync_processes();
          }
        } else {
          return new BindProcess(this, onchange_construction, f);
        }
      } //  ...

    }, {
      key: "unbind",
      value: function unbind(f) {
        var len, q, ref, results, v;

        if (f instanceof Process) {
          this._processes.splice(this._processes.indexOf(f), 1);

          return f._models.splice(f._models.indexOf(this), 1);
        } else {
          ref = this._processes;
          results = [];

          for (q = 0, len = ref.length; q < len; q++) {
            v = ref[q];

            if (v instanceof BindProcess && v.f === f) {
              results.push(this.unbind(v));
            }
          }

          return results;
        }
      } // return a copy of data in a "standard" representation (e.g. string, number, objects, ...)
      // users are encouraged to use Models as much as possible
      // (meaning that get should not be called for every manipulation),
      // adding methods for manipulation of data if necessary
      // (e.g. toggle, find, ... in Lst, Str, ...).
      // May be redefined for specific types (e.g. Str, Lst, ...)

    }, {
      key: "get",
      value: function get() {
        var len, name, q, ref, res;
        res = {};
        ref = this._attribute_names;

        for (q = 0, len = ref.length; q < len; q++) {
          name = ref[q];
          res[name] = this[name].get();
        }

        return res;
      } // modify data, using another values, or Model instances.
      // Should not be redefined (but _set should be)
      // returns true if object os modified

    }, {
      key: "set",
      value: function set(value) {
        if (this._set(value)) {
          // change internal data
          this._signal_change();

          return true;
        }

        return false;
      } // modify state according to str. str can be the result of a previous @get_state

    }, {
      key: "set_state",
      value: function set_state(str) {
        var l, len, lst, map, mid, q, s;
        map = {};
        lst = str.split("\n");
        mid = lst.shift();

        for (q = 0, len = lst.length; q < len; q++) {
          l = lst[q];

          if (!l.length) {
            continue;
          }

          s = l.split(" ");
          map[s[0]] = {
            type: s[1],
            data: s[2],
            buff: void 0
          };
        } // fill / update this with data in map[ mid ]


        map[mid].buff = this;
        return this._set_state(map[mid].data, map);
      } // return a string which describes the changes in this and children since date

    }, {
      key: "get_state",
      value: function get_state() {
        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
        var fmm, id, obj, res; // get sub models

        fmm = {};

        this._get_flat_model_map(fmm, date);

        res = this.model_id.toString();

        if (this._date_last_modification > date) {
          for (id in fmm) {
            obj = fmm[id];
            res += "\n" + obj.model_id + " " + ModelProcessManager.get_object_class(obj) + " " + obj._get_state();
          }
        }

        return res;
      } // add attribute (p.values must contain models)
      // can be called with
      //  - name, instance of Model (two arguments)
      //  - { name_1: instance_1, name_2: instance_2, ... } (only one argument)

    }, {
      key: "add_attr",
      value: function add_attr(n, p) {
        var signal_change = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var key, results, val; // name, model

        if (p != null) {
          if (typeof p === "function") {
            return this[n] = p;
          } else {
            if (this[n] != null) {
              console.error("attribute ".concat(n, " already exists in ") + "".concat(ModelProcessManager.get_object_class(this)));
            }

            p = ModelProcessManager.conv(p);

            if (indexOf.call(p._parents, this) < 0) {
              p._parents.push(this);
            }

            this._attribute_names.push(n);

            this[n] = p;

            if (signal_change) {
              return this._signal_change();
            }
          }
        } else {
          // else, asuming { name_1: instance_1, name_2: instance_2, ... }
          results = [];

          for (key in n) {
            val = n[key];

            if (val != null) {
              results.push(this.add_attr(key, val, signal_change));
            }
          }

          return results;
        }
      } // remove attribute named name

    }, {
      key: "rem_attr",
      value: function rem_attr(name) {
        var signal_change = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var c, i;
        c = this[name];

        if (c) {
          i = c._parents.indexOf(this);

          if (i >= 0) {
            c._parents.splice(i, 1);

            if (c._parents.length === 0) {
              c.destructor();
            }
          }

          delete this[name];
          i = this._attribute_names.indexOf(name);

          if (i >= 0) {
            this._attribute_names.splice(i, 1);
          }

          if (signal_change) {
            return this._signal_change();
          }
        }
      } // change attribute named n to p (use references for comparison)

    }, {
      key: "mod_attr",
      value: function mod_attr(n, p) {
        if (this[n] !== p) {
          this.rem_attr(n);
          return this.add_attr(n, p);
        }
      } // add / mod / rem attr to get the same data than o
      //  (assumed to be something like { key: val, ... })

    }, {
      key: "set_attr",
      value: function set_attr(o) {
        var k, len, q, r, results, to_rem, v; // new ones / updates

        for (k in o) {
          v = o[k];
          this.mod_attr(k, v);
        } // remove


        to_rem = function () {
          var len, q, ref, results;
          ref = this._attribute_names;
          results = [];

          for (q = 0, len = ref.length; q < len; q++) {
            k = ref[q];

            if (o[k] == null) {
              results.push(k);
            }
          }

          return results;
        }.call(this);

        results = [];

        for (q = 0, len = to_rem.length; q < len; q++) {
          r = to_rem[q];
          results.push(this.rem_attr(r));
        }

        return results;
      } // dimension of the object -> [] for a scalar, [ length ] for a vector,
      //  [ nb_row, nb_cols ] for a matrix...

    }, {
      key: "size",
      value: function size() {
        var for_display = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        return [];
      } // dimensionnality of the object -> 0 for a scalar, 1 for a vector, ...

    }, {
      key: "dim",
      value: function dim() {
        var for_display = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        return this.size(for_display).length;
      }
    }, {
      key: "equals",
      value: function equals(m) {
        var key, len, len1, q, ref, ref1, u, val, y;

        if (this === m) {
          return true;
        }

        if (m._attribute_names != null) {
          u = {};
          ref = m._attribute_names;

          for (q = 0, len = ref.length; q < len; q++) {
            key = ref[q];
            val = m[key];

            if (this[key] == null) {
              return false;
            }

            if (!this[key].equals(val)) {
              return false;
            }

            u[key] = true;
          }

          ref1 = this._attribute_names;

          for (y = 0, len1 = ref1.length; y < len1; y++) {
            key = ref1[y];

            if (u[key] == null) {
              return false;
            }
          }
        }

        return false;
      } // get first parents that checks func_to_check

    }, {
      key: "get_parents_that_check",
      value: function get_parents_that_check(func_to_check) {
        var res, visited;
        res = [];
        visited = {};

        this._get_parents_that_check_rec(res, visited, func_to_check);

        return res;
      }
    }, {
      key: "deep_copy",
      value: function deep_copy() {
        var key, len, o, q, ref;
        o = {};
        ref = this._attribute_names;

        for (q = 0, len = ref.length; q < len; q++) {
          key = ref[q];
          o[key] = this[key].deep_copy();
        }

        eval("var __new__ = new ".concat(ModelProcessManager.get_object_class(this), ";"));

        __new__.set_attr(o);

        return __new__;
      } // returns true if change is not "cosmetic"

    }, {
      key: "real_change",
      value: function real_change() {
        var a, len, q, ref;

        if (this.has_been_directly_modified() && !this._attribute_names.length) {
          return true;
        }

        ref = this._attribute_names;

        for (q = 0, len = ref.length; q < len; q++) {
          a = ref[q];

          if (typeof this.cosmetic_attribute === "function" ? this.cosmetic_attribute(a) : void 0) {
            continue;
          }

          if (this[a].real_change()) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "cosmetic_attribute",
      value: function cosmetic_attribute(name) {
        return false;
      } // may be redefined

    }, {
      key: "_get_state",
      value: function _get_state() {
        var name, str;

        str = function () {
          var len, q, ref, results;
          ref = this._attribute_names;
          results = [];

          for (q = 0, len = ref.length; q < len; q++) {
            name = ref[q];
            results.push(name + ":" + this[name].model_id);
          }

          return results;
        }.call(this);

        return str.join(",");
      } // send data to server

    }, {
      key: "_get_fs_data",
      value: function _get_fs_data(out) {
        var name, obj, str;
        FileSystem.set_server_id_if_necessary(out, this);

        str = function () {
          var len, q, ref, results;
          ref = this._attribute_names;
          results = [];

          for (q = 0, len = ref.length; q < len; q++) {
            name = ref[q];
            obj = this[name];
            FileSystem.set_server_id_if_necessary(out, obj);
            results.push(name + ":" + obj._server_id);
          }

          return results;
        }.call(this);

        return out.mod += "C ".concat(this._server_id, " ").concat(str.join(","), " ");
      } // may be redefined.
      // by default, add attributes using keys and values (and remove old unused values)
      // must return true if data is changed

    }, {
      key: "_set",
      value: function _set(value) {
        var change, key, len, len1, q, ref, ref1, used, val, y;
        change = false; // rem

        used = {};
        ref = ModelProcessManager._get_attribute_names(value);

        for (q = 0, len = ref.length; q < len; q++) {
          key = ref[q];
          used[key] = true;
        }

        ref1 = function () {
          var len1, ref1, results, z;
          ref1 = this._attribute_names;
          results = [];

          for (z = 0, len1 = ref1.length; z < len1; z++) {
            key = ref1[z];

            if (!used[key]) {
              results.push(key);
            }
          }

          return results;
        }.call(this);

        for (y = 0, len1 = ref1.length; y < len1; y++) {
          key = ref1[y];
          change = true;
          this.rem_attr(key, false);
        } // mod / add


        for (key in value) {
          val = value[key];

          if (val != null) {
            if (this[key] != null) {
              if (this[key].constructor === val.constructor) {
                change |= this[key].set(val);
              } else {
                change = true;
                this.mod_attr(key, val, false);
              }
            } else {
              this.add_attr(key, val, false);
            }
          }
        }

        return change;
      } // called by set. change_level should not be defined by the user
      //  (it permits to != change from child of from this)

    }, {
      key: "_signal_change",
      value: function _signal_change() {
        var change_level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;
        var len, p, q, ref;

        if (change_level === 2 && this._server_id != null) {
          FileSystem.signal_change(this);
        } // register this as a modified model


        ModelProcessManager._modlist[this.model_id] = this; // do the same thing for the parents

        if (this._date_last_modification <= ModelProcessManager._counter) {
          this._date_last_modification = ModelProcessManager._counter + change_level;
          ref = this._parents;

          for (q = 0, len = ref.length; q < len; q++) {
            p = ref[q];

            p._signal_change(1);
          }
        } // start if not done a timer


        return ModelProcessManager._need_sync_processes();
      } // generic definition of _set_state. ( called by _use_state )

    }, {
      key: "_set_state",
      value: function _set_state(str, map) {
        var attr, inr, k_id, len, len1, q, ref, ref1, results, spl, u, y;
        u = {}; // used attributes. Permits to know what to destroy

        if (str.length) {
          ref = str.split(",");

          for (q = 0, len = ref.length; q < len; q++) {
            spl = ref[q];
            inr = spl.split(":");
            attr = inr[0];
            k_id = inr[1];
            u[attr] = true; // if already defined in the map

            if (map[k_id].buff != null) {
              if (this[attr] == null) {
                this.add_attr(attr, map[k_id].buff);
              } else if (map[k_id].buff !== this[attr]) {
                this.mod_attr(attr, map[k_id].buff);
              } // else, if the attribute does not exist, we create if

            } else if (this[attr] == null) {
              this.add_attr(attr, ModelProcessManager._new_model_from_state(k_id, map)); // else, we already have an attribute and map has not been already explored
            } else if (!this[attr]._set_state_if_same_type(k_id, map)) {
              this.mod_attr(attr, ModelProcessManager._new_model_from_state(k_id, map));
            }
          }
        }

        ref1 = this._attribute_names;
        results = [];

        for (y = 0, len1 = ref1.length; y < len1; y++) {
          attr = ref1[y];

          if (!u[attr]) {
            results.push(this.rem_attr(attr));
          } else {
            results.push(void 0);
          }
        }

        return results;
      } // see get_parents_that_check

    }, {
      key: "_get_parents_that_check_rec",
      value: function _get_parents_that_check_rec(res, visited, func_to_check) {
        var len, p, q, ref, results;

        if (visited[this.model_id] == null) {
          visited[this.model_id] = true;

          if (func_to_check(this)) {
            return res.push(this);
          } else {
            ref = this._parents;
            results = [];

            for (q = 0, len = ref.length; q < len; q++) {
              p = ref[q];
              results.push(p._get_parents_that_check_rec(res, visited, func_to_check));
            }

            return results;
          }
        }
      } // return true if info from map[ mid ] if compatible with this.
      // If it's the case, use this information to update data

    }, {
      key: "_set_state_if_same_type",
      value: function _set_state_if_same_type(mid, map) {
        var dat;
        dat = map[mid];

        if (ModelProcessManager.get_object_class(this) === dat.type) {
          dat.buff = this;

          this._set_state(dat.data, map);

          return true;
        }

        return false;
      } // map[ id ] = obj for each objects starting from this recursively

    }, {
      key: "_get_flat_model_map",
      value: function _get_flat_model_map(map, date) {
        var len, name, obj, q, ref, results;
        map[this.model_id] = this;
        ref = this._attribute_names;
        results = [];

        for (q = 0, len = ref.length; q < len; q++) {
          name = ref[q];
          obj = this[name];

          if (map[obj.model_id] == null) {
            if (obj._date_last_modification > date) {
              results.push(obj._get_flat_model_map(map, date));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }

        return results;
      }
    }]);

    return Model;
  }();

  spinalCore.register_models(Model);
  root.Model = Model; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // generic object with data

  root = typeof _root_obj === "undefined" ? global : window;

  Obj =
  /*#__PURE__*/
  function (_spinalCore$_def$Mode) {
    _inherits(Obj, _spinalCore$_def$Mode);

    function Obj(data) {
      var _this;

      _classCallCheck(this, Obj);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Obj).call(this));

      if (data != null) {
        _this._set(data);
      }

      return _this;
    }

    _createClass(Obj, [{
      key: "toString",
      value: function toString() {
        var ref;
        return (ref = this._data) != null ? ref.toString() : void 0;
      }
    }, {
      key: "equals",
      value: function equals(obj) {
        if (obj instanceof Obj) {
          return this._data === obj._data;
        }

        return this._data === obj;
      }
    }, {
      key: "get",
      value: function get() {
        return this._data;
      }
    }, {
      key: "_get_fs_data",
      value: function _get_fs_data(out) {
        FileSystem.set_server_id_if_necessary(out, this);
        return out.mod += "C ".concat(this._server_id, " ").concat(this.toString(), " ");
      }
    }, {
      key: "_set",
      value: function _set(value) {
        if (this._data !== value) {
          this._data = value;
          return true;
        }

        return false;
      }
    }, {
      key: "_get_state",
      value: function _get_state() {
        return this._data;
      }
    }, {
      key: "_set_state",
      value: function _set_state(str, map) {
        return this.set(str);
      }
    }]);

    return Obj;
  }(spinalCore._def["Model"]);

  spinalCore.register_models(Obj);
  root.Obj = Obj; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // value choosen from a list
  // get() will give the value
  // num is the number of the choosen value in the list
  // lst contains the posible choices

  root = typeof _root_obj === "undefined" ? global : window;

  Choice =
  /*#__PURE__*/
  function (_spinalCore$_def$Mode2) {
    _inherits(Choice, _spinalCore$_def$Mode2);

    function Choice(data) {
      var _this2;

      var initial_list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      _classCallCheck(this, Choice);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Choice).call(this)); // default

      _this2.add_attr({
        num: 0,
        lst: initial_list
      }); // init


      if (data != null) {
        _this2.num.set(data);
      }

      return _this2;
    }

    _createClass(Choice, [{
      key: "filter",
      value: function filter(obj) {
        return true;
      }
    }, {
      key: "item",
      value: function item() {
        return this._nlst()[this.num.get()];
      }
    }, {
      key: "get",
      value: function get() {
        var ref;
        return (ref = this.item()) != null ? ref.get() : void 0;
      }
    }, {
      key: "toString",
      value: function toString() {
        var ref;
        return (ref = this.item()) != null ? ref.toString() : void 0;
      }
    }, {
      key: "equals",
      value: function equals(a) {
        if (a instanceof Choice) {
          return _get(_getPrototypeOf(Choice.prototype), "equals", this).call(this, a);
        } else {
          return this._nlst()[this.num.get()].equals(a);
        }
      }
    }, {
      key: "_set",
      value: function _set(value) {
        var i, j, len, q, ref;
        ref = this._nlst();

        for (j = q = 0, len = ref.length; q < len; j = ++q) {
          i = ref[j];

          if (i.equals(value)) {
            return this.num.set(j);
          }
        }

        return this.num.set(value);
      }
    }, {
      key: "_nlst",
      value: function _nlst() {
        var l, len, q, ref, results;
        ref = this.lst;
        results = [];

        for (q = 0, len = ref.length; q < len; q++) {
          l = ref[q];

          if (this.filter(l)) {
            results.push(l);
          }
        }

        return results;
      }
    }]);

    return Choice;
  }(spinalCore._def["Model"]);

  spinalCore.register_models(Choice);
  root.Choice = Choice; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // false by default

  root = typeof _root_obj === "undefined" ? global : window;

  Bool =
  /*#__PURE__*/
  function (_spinalCore$_def$Obj) {
    _inherits(Bool, _spinalCore$_def$Obj);

    function Bool(data) {
      var _this3;

      _classCallCheck(this, Bool);

      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Bool).call(this));
      _this3._data = false; // default values

      if (data != null) {
        _this3._set(data);
      }

      return _this3;
    } // toggle true / false ( 1 / 0 )


    _createClass(Bool, [{
      key: "toggle",
      value: function toggle() {
        return this.set(!this._data);
      }
    }, {
      key: "toBoolean",
      value: function toBoolean() {
        return this._data;
      }
    }, {
      key: "deep_copy",
      value: function deep_copy() {
        return new Bool(this._data);
      } // we do not take _set from Obj because we want a conversion if value is not a boolean

    }, {
      key: "_set",
      value: function _set(value) {
        var n;

        if (n instanceof Model) {
          n = value.toBoolean();
        } else if (value === "false") {
          n = false;
        } else if (value === "true") {
          n = true;
        } else {
          n = Boolean(value);
        }

        if (this._data !== n) {
          this._data = n;
          return true;
        }

        return false;
      }
    }, {
      key: "_get_fs_data",
      value: function _get_fs_data(out) {
        FileSystem.set_server_id_if_necessary(out, this);
        return out.mod += "C ".concat(this._server_id, " ").concat(1 * Boolean(this._data), " ");
      }
    }]);

    return Bool;
  }(spinalCore._def["Obj"]);

  spinalCore.register_models(Bool);
  root.Bool = Bool; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.

  root = typeof _root_obj === "undefined" ? global : window;

  ConstOrNotModel =
  /*#__PURE__*/
  function (_spinalCore$_def$Mode3) {
    _inherits(ConstOrNotModel, _spinalCore$_def$Mode3);

    function ConstOrNotModel(bool, model) {
      var _this4;

      var check_disabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      _classCallCheck(this, ConstOrNotModel);

      _this4 = _possibleConstructorReturn(this, _getPrototypeOf(ConstOrNotModel).call(this)); // default

      _this4.add_attr({
        bool: bool,
        model: model,
        check_disabled: check_disabled
      });

      return _this4;
    }

    _createClass(ConstOrNotModel, [{
      key: "get",
      value: function get() {
        var ref;
        return (ref = this.model) != null ? ref.get() : void 0;
      }
    }, {
      key: "set",
      value: function set(value) {
        var ref;
        return (ref = this.model) != null ? ref.set(value) : void 0;
      }
    }, {
      key: "toString",
      value: function toString() {
        var ref;
        return (ref = this.model) != null ? ref.toString() : void 0;
      }
    }]);

    return ConstOrNotModel;
  }(spinalCore._def["Model"]);

  spinalCore.register_models(ConstOrNotModel);
  root.ConstOrNotModel = ConstOrNotModel; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // scalar

  root = typeof _root_obj === "undefined" ? global : window;

  ConstrainedVal =
  /*#__PURE__*/
  function (_spinalCore$_def$Mode4) {
    _inherits(ConstrainedVal, _spinalCore$_def$Mode4);

    function ConstrainedVal(value) {
      var _this5;

      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, ConstrainedVal);

      _this5 = _possibleConstructorReturn(this, _getPrototypeOf(ConstrainedVal).call(this));

      _this5.add_attr({
        val: value || 0,
        _min: params.min != null ? params.min : 0,
        _max: params.max != null ? params.max : 100
      });

      _this5.add_attr({
        _div: params.div != null ? params.div : _this5._max - _this5._min
      });

      return _this5;
    }

    _createClass(ConstrainedVal, [{
      key: "get",
      value: function get() {
        return this.val.get();
      }
    }, {
      key: "ratio",
      value: function ratio() {
        return (this.val.get() - this._min.get()) / this.delta();
      }
    }, {
      key: "delta",
      value: function delta() {
        return this._max.get() - this._min.get();
      }
    }, {
      key: "set_params",
      value: function set_params(params) {
        this._min.set(params.min != null ? params.min : 0);

        this._max.set(params.max != null ? params.max : 100);

        return this._div.set(params.div != null ? params.div : this._max - this._min);
      }
    }, {
      key: "_set",
      value: function _set(value) {
        var res;

        if (value instanceof ConstrainedVal) {
          return this.val._set(value.get());
        }

        res = this.val.set(value);

        this._check_val();

        return res;
      }
    }, {
      key: "_check_val",
      value: function _check_val() {
        var d, m, n, r, s, v;
        v = this.val.get();
        m = this._min.get();
        n = this._max.get();
        d = this._div.get();

        if (v < m) {
          this.val.set(m);
        }

        if (v > n) {
          this.val.set(n);
        }

        if (d) {
          s = (n - m) / d;
          r = m + Math.round((this.val.get() - m) / s) * s;
          return this.val.set(r);
        }
      }
    }]);

    return ConstrainedVal;
  }(spinalCore._def["Model"]);

  spinalCore.register_models(ConstrainedVal);
  root.ConstrainedVal = ConstrainedVal; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // vector of objects inherited from Model

  root = typeof _root_obj === "undefined" ? global : window;

  Lst =
  /*#__PURE__*/
  function (_spinalCore$_def$Mode5) {
    _inherits(Lst, _spinalCore$_def$Mode5);

    function Lst(data) {
      var _this6;

      _classCallCheck(this, Lst);

      var d, i, q, ref, s;
      _this6 = _possibleConstructorReturn(this, _getPrototypeOf(Lst).call(this)); // default

      _this6.length = 0; // static length case

      s = _this6.static_length();

      if (s >= 0) {
        d = _this6.default_value();

        for (i = q = 0, ref = s; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
          _this6.push(d, true);
        }
      } // init


      if (data != null) {
        _this6._set(data);
      }

      return _this6;
    } // if static_length < 0, length is dynamic (push, pop, ... are allowed)
    // else, length = static_length
    // may be redefined


    _createClass(Lst, [{
      key: "static_length",
      value: function static_length() {
        return -1;
      } // used for initialisation of for resize
      // may be redefined

    }, {
      key: "default_value",
      value: function default_value() {
        return 0;
      } // if base_type is defined, all values must be of this type

    }, {
      key: "base_type",
      value: function base_type() {
        return void 0;
      }
    }, {
      key: "get",
      value: function get() {
        var i, len, q, ref, results;
        ref = this;
        results = [];

        for (q = 0, len = ref.length; q < len; q++) {
          i = ref[q];
          results.push(i.get());
        }

        return results;
      } // tensorial size (see models)

    }, {
      key: "size",
      value: function size() {
        return [length];
      }
    }, {
      key: "toString",
      value: function toString() {
        var l, x;

        if (this.length) {
          l = function () {
            var len, q, ref, results;
            ref = this;
            results = [];

            for (q = 0, len = ref.length; q < len; q++) {
              x = ref[q];
              results.push(x.toString());
            }

            return results;
          }.call(this);

          return l.join();
        } else {
          return "";
        }
      }
    }, {
      key: "equals",
      value: function equals(lst) {
        var i, q, ref;

        if (this.length !== lst.length) {
          return false;
        }

        for (i = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
          if (!this[i].equals(lst[i])) {
            return false;
          }
        }

        return true;
      } // append value at the end of the list

    }, {
      key: "push",
      value: function push(value) {
        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var b;

        if (this._static_size_check(force)) {
          return;
        }

        b = this.base_type();

        if (b != null) {
          if (!(value instanceof b)) {
            value = new b(value);
          }
        } else {
          value = ModelProcessManager.conv(value);
        }

        if (indexOf.call(value._parents, this) < 0) {
          value._parents.push(this);
        }

        this[this.length] = value;
        this.length += 1;
        return this._signal_change();
      } // remove and return the last element

    }, {
      key: "pop",
      value: function pop() {
        var old;

        if (this._static_size_check(false)) {
          return;
        }

        if (this.length <= 0) {
          return;
        }

        this.length -= 1;
        old = this[this.length];
        this.rem_attr(this.length);
        return old;
      }
    }, {
      key: "clear",
      value: function clear() {
        var results;
        results = [];

        while (this.length) {
          results.push(this.pop());
        }

        return results;
      } // add an element to the beginning of an array, return the new length

    }, {
      key: "unshift",
      value: function unshift(element) {
        var b, i, q, ref;

        if (this._static_size_check(false)) {
          return;
        }

        b = this.base_type();

        if (b != null) {
          if (!(element instanceof b)) {
            element = new b(element);
          }
        } else {
          element = ModelProcessManager.conv(element);
        }

        if (indexOf.call(element._parents, this) < 0) {
          element._parents.push(this);
        }

        if (this.length) {
          for (i = q = ref = this.length - 1; ref <= 0 ? q <= 0 : q >= 0; i = ref <= 0 ? ++q : --q) {
            this[i + 1] = this[i];
          }
        }

        this[0] = element;
        this.length += 1;

        this._signal_change();

        return this.length;
      } // remove and return the first element

    }, {
      key: "shift",
      value: function shift() {
        var r;
        r = this[0];
        this.splice(0, 1);
        return r;
      } // remove item from the list id present

    }, {
      key: "remove",
      value: function remove(item) {
        var i;
        i = this.indexOf(item);

        if (i >= 0) {
          return this.splice(i, 1);
        }
      } // remove item from the list id present, based on ref comparison

    }, {
      key: "remove_ref",
      value: function remove_ref(item) {
        var i;
        i = this.indexOf_ref(item);

        if (i >= 0) {
          return this.splice(i, 1);
        }
      } // return a list with item such as f( item ) is true

    }, {
      key: "filter",
      value: function filter(f) {
        var i, len, q, ref, results;
        ref = this;
        results = [];

        for (q = 0, len = ref.length; q < len; q++) {
          i = ref[q];

          if (f(i)) {
            results.push(i);
          }
        }

        return results;
      } // return the first item such as f( item ) is true. If not item, return undefined

    }, {
      key: "detect",
      value: function detect(f) {
        var i, len, q, ref;
        ref = this;

        for (q = 0, len = ref.length; q < len; q++) {
          i = ref[q];

          if (f(i)) {
            return i;
          }
        }

        return void 0;
      } // sort item depending function and return a new Array

    }, {
      key: "sorted",
      value: function sorted(fun_sort) {
        var it, len, new_array, q, ref; // lst to array

        new_array = new Array();
        ref = this;

        for (q = 0, len = ref.length; q < len; q++) {
          it = ref[q];
          new_array.push(it);
        } //sort array


        new_array.sort(fun_sort);
        return new_array;
      } // return true if there is an item that checks f( item )

    }, {
      key: "has",
      value: function has(f) {
        var i, len, q, ref;
        ref = this;

        for (q = 0, len = ref.length; q < len; q++) {
          i = ref[q];

          if (f(i)) {
            return true;
          }
        }

        return false;
      } // returns index of v if v is present in the list. Else, return -1

    }, {
      key: "indexOf",
      value: function indexOf(v) {
        var i, q, ref;

        for (i = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
          if (this[i].equals(v)) {
            return i;
          }
        }

        return -1;
      } // returns index of v if v is present in the list, based on ref comparison. Else, return -1

    }, {
      key: "indexOf_ref",
      value: function indexOf_ref(v) {
        var i, q, ref;

        for (i = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
          if (this[i] === v) {
            return i;
          }
        }

        return -1;
      }
    }, {
      key: "contains",
      value: function contains(v) {
        return this.indexOf(v) >= 0;
      }
    }, {
      key: "contains_ref",
      value: function contains_ref(v) {
        return this.indexOf_ref(v) >= 0;
      } // toggle presence of v. return true if added

    }, {
      key: "toggle",
      value: function toggle(v) {
        var i;
        i = this.indexOf(v);

        if (i >= 0) {
          this.splice(i);
          return false;
        } else {
          this.push(v);
          return true;
        }
      } // toggle presence of v, base on ref comparison

    }, {
      key: "toggle_ref",
      value: function toggle_ref(v) {
        var i;
        i = this.indexOf_ref(v);

        if (i >= 0) {
          this.splice(i);
          return false;
        } else {
          this.push(v);
          return true;
        }
      } //return a new lst between begin and end index

    }, {
      key: "slice",
      value: function slice(begin) {
        var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;
        var i, q, ref, ref1, tab;

        if (begin < 0) {
          begin = 0;
        }

        if (end > this.length) {
          end = this.length;
        }

        tab = new Lst();

        for (i = q = ref = begin, ref1 = end; ref <= ref1 ? q < ref1 : q > ref1; i = ref <= ref1 ? ++q : --q) {
          tab.push(this[i].get());
        }

        return tab;
      } //return list with new_tab after

    }, {
      key: "concat",
      value: function concat(new_tab) {
        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var el, len, q;

        if (this._static_size_check(force)) {
          return;
        }

        if (new_tab.length) {
          for (q = 0, len = new_tab.length; q < len; q++) {
            el = new_tab[q];
            this.push(el);
          }

          return this;
        }
      } // remove n items from index

    }, {
      key: "splice",
      value: function splice(index) {
        var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var i, q, ref, ref1, ref2, ref3, ref4, ref5, y, z;

        if (this._static_size_check(false)) {
          return;
        }

        for (i = q = ref = index, ref1 = Math.min(index + n, this.length); ref <= ref1 ? q < ref1 : q > ref1; i = ref <= ref1 ? ++q : --q) {
          this.rem_attr(i);
        }

        for (i = y = ref2 = index, ref3 = this.length - n; ref2 <= ref3 ? y < ref3 : y > ref3; i = ref2 <= ref3 ? ++y : --y) {
          this[i] = this[i + n];
        }

        for (i = z = ref4 = this.length - n, ref5 = this.length; ref4 <= ref5 ? z < ref5 : z > ref5; i = ref4 <= ref5 ? ++z : --z) {
          delete this[i];
        }

        this.length -= n;
        return this._signal_change();
      } // remove n items before index

    }, {
      key: "insert",
      value: function insert(index, list) {
        var i, l, len, len1, o, q, results, y;

        if (list.length) {
          l = Math.max(this.length - index, 0);

          o = function () {
            var q, ref, results;
            results = [];

            for (i = q = 0, ref = l; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
              results.push(this.pop());
            }

            return results;
          }.call(this);

          o.reverse();

          for (q = 0, len = list.length; q < len; q++) {
            l = list[q];
            this.push(l);
          }

          results = [];

          for (y = 0, len1 = o.length; y < len1; y++) {
            l = o[y];
            results.push(this.push(l));
          }

          return results;
        }
      } // permits to set an item or to grow the list if index == @length

    }, {
      key: "set_or_push",
      value: function set_or_push(index, val) {
        if (index < this.length) {
          return this.mod_attr(index, val);
        } else if (index === this.length) {
          return this.push(val);
        }
      } // permits to reduce the size (resize is allowed only if we known how to create new items)

    }, {
      key: "trim",
      value: function trim(size) {
        var results;
        results = [];

        while (this.length > size) {
          results.push(this.pop());
        }

        return results;
      } // return a string with representation of items, separated by sep

    }, {
      key: "join",
      value: function join(sep) {
        return this.get().join(sep);
      }
    }, {
      key: "deep_copy",
      value: function deep_copy() {
        var i, q, ref, res;
        res = new Lst();

        for (i = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
          res.push(this[i].deep_copy());
        }

        return res;
      } // last element

    }, {
      key: "back",
      value: function back() {
        return this[this.length - 1];
      } // returns true if change is not "cosmetic"

    }, {
      key: "real_change",
      value: function real_change() {
        var a, len, q, ref;

        if (this.has_been_directly_modified()) {
          return true;
        }

        ref = this;

        for (q = 0, len = ref.length; q < len; q++) {
          a = ref[q];

          if (a.real_change()) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "_set",
      value: function _set(value) {
        var change, p, q, ref, s;
        change = this.length !== value.length;
        s = this.static_length();

        if (s >= 0 && change) {
          console.error("resizing a static array (type " + "".concat(ModelProcessManager.get_object_class(this), ") is forbidden"));
        }

        for (p = q = 0, ref = value.length; 0 <= ref ? q < ref : q > ref; p = 0 <= ref ? ++q : --q) {
          if (p < this.length) {
            change |= this[p].set(value[p]);
          } else if (s < 0) {
            this.push(value[p]);
          }
        }

        if (s < 0) {
          while (this.length > value.length) {
            this.pop();
          }

          this.length = value.length;
        }

        return change;
      }
    }, {
      key: "_get_flat_model_map",
      value: function _get_flat_model_map(map, date) {
        var len, obj, q, ref, results;
        map[this.model_id] = this;
        ref = this;
        results = [];

        for (q = 0, len = ref.length; q < len; q++) {
          obj = ref[q];

          if (map[obj.model_id] == null) {
            if (obj._date_last_modification > date) {
              results.push(obj._get_flat_model_map(map, date));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }

        return results;
      }
    }, {
      key: "_get_fs_data",
      value: function _get_fs_data(out) {
        var obj, str;
        FileSystem.set_server_id_if_necessary(out, this);

        str = function () {
          var len, q, ref, results;
          ref = this;
          results = [];

          for (q = 0, len = ref.length; q < len; q++) {
            obj = ref[q];
            FileSystem.set_server_id_if_necessary(out, obj);
            results.push(obj._server_id);
          }

          return results;
        }.call(this);

        return out.mod += "C ".concat(this._server_id, " ").concat(str.join(","), " ");
      }
    }, {
      key: "_get_state",
      value: function _get_state() {
        var obj, str;

        str = function () {
          var len, q, ref, results;
          ref = this;
          results = [];

          for (q = 0, len = ref.length; q < len; q++) {
            obj = ref[q];
            results.push(obj.model_id);
          }

          return results;
        }.call(this);

        return str.join(",");
      }
    }, {
      key: "_set_state",
      value: function _set_state(str, map) {
        var attr, k_id, l_id, q, ref, ref1, ref2, results, y;
        l_id = str.split(",").filter(function (x) {
          return x.length;
        });

        while (this.length > l_id.length) {
          this.pop();
        }

        for (attr = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; attr = 0 <= ref ? ++q : --q) {
          k_id = l_id[attr]; //             if not map[ k_id ]?
          //                 console.log map, k_id

          if (map[k_id].buff != null) {
            if (map[k_id].buff !== this[attr]) {
              this.mod_attr(attr, map[k_id].buff);
            }
          } else if (!this[attr]._set_state_if_same_type(k_id, map)) {
            this.mod_attr(attr, ModelProcessManager._new_model_from_state(k_id, map));
          }
        }

        results = [];

        for (attr = y = ref1 = this.length, ref2 = l_id.length; ref1 <= ref2 ? y < ref2 : y > ref2; attr = ref1 <= ref2 ? ++y : --y) {
          k_id = l_id[attr];

          if (map[k_id].buff != null) {
            results.push(this.push(map[k_id].buff));
          } else {
            results.push(this.push(ModelProcessManager._new_model_from_state(k_id, map)));
          }
        }

        return results;
      }
    }, {
      key: "_static_size_check",
      value: function _static_size_check(force) {
        if (this.static_length() >= 0 && !force) {
          console.error("resizing a static array (type " + "".concat(ModelProcessManager.get_object_class(this), ") is forbidden"));
          return true;
        }

        return false;
      }
    }]);

    return Lst;
  }(spinalCore._def["Model"]);

  spinalCore.register_models(Lst);
  root.Lst = Lst; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // scalar

  root = typeof _root_obj === "undefined" ? global : window;

  Val =
  /*#__PURE__*/
  function (_spinalCore$_def$Obj2) {
    _inherits(Val, _spinalCore$_def$Obj2);

    function Val(data) {
      var _this7;

      _classCallCheck(this, Val);

      _this7 = _possibleConstructorReturn(this, _getPrototypeOf(Val).call(this));
      _this7._data = 0; // default values

      if (data != null) {
        _this7._set(data);
      }

      return _this7;
    } // toggle true / false ( 1 / 0 )


    _createClass(Val, [{
      key: "toggle",
      value: function toggle() {
        return this.set(!this._data);
      }
    }, {
      key: "toBoolean",
      value: function toBoolean() {
        return Boolean(this._data);
      }
    }, {
      key: "deep_copy",
      value: function deep_copy() {
        return new Val(this._data);
      }
    }, {
      key: "add",
      value: function add(v) {
        if (v) {
          this._data += v;
          return this._signal_change();
        }
      } // we do not take _set from Obj because we want a conversion if value is not a number

    }, {
      key: "_set",
      value: function _set(value) {
        var n; // console.log value

        if (typeof value === "string") {
          if (value.slice(0, 2) === "0x") {
            n = parseInt(value, 16);
          } else {
            n = parseFloat(value);

            if (isNaN(n)) {
              n = parseInt(value);
            }

            if (isNaN(n)) {
              console.log("Don't know how to transform ".concat(value, " to a Val"));
            }
          }
        } else if (typeof value === "boolean") {
          n = 1 * value;
        } else if (value instanceof Val) {
          n = value._data; // assuming a number
        } else {
          n = value;
        }

        if (this._data !== n) {
          this._data = n;
          return true;
        }

        return false;
      }
    }]);

    return Val;
  }(spinalCore._def["Obj"]);

  spinalCore.register_models(Val);
  root.Val = Val; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.

  root = typeof _root_obj === "undefined" ? global : window;

  Vec =
  /*#__PURE__*/
  function (_spinalCore$_def$Lst) {
    _inherits(Vec, _spinalCore$_def$Lst);

    function Vec(data) {
      _classCallCheck(this, Vec);

      return _possibleConstructorReturn(this, _getPrototypeOf(Vec).call(this, data));
    }

    _createClass(Vec, [{
      key: "base_type",
      value: function base_type() {
        return Val;
      }
    }, {
      key: "_underlying_fs_type",
      value: function _underlying_fs_type() {
        return "Lst";
      }
    }]);

    return Vec;
  }(spinalCore._def["Lst"]);

  spinalCore.register_models(Vec);
  root.Vec = Vec; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // String

  root = typeof _root_obj === "undefined" ? global : window;

  Str =
  /*#__PURE__*/
  function (_spinalCore$_def$Obj3) {
    _inherits(Str, _spinalCore$_def$Obj3);

    function Str(data) {
      var _this8;

      _classCallCheck(this, Str);

      _this8 = _possibleConstructorReturn(this, _getPrototypeOf(Str).call(this)); // default value

      _this8._data = "";
      _this8.length = 0; // init if possible

      if (data != null) {
        _this8._set(data);
      }

      return _this8;
    } // toggle presence of str in this


    _createClass(Str, [{
      key: "toggle",
      value: function toggle(str) {
        var space = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : " ";
        var i, l;
        l = this._data.split(space);
        i = l.indexOf(str);

        if (i < 0) {
          l.push(str);
        } else {
          l.splice(i, 1);
        }

        return this.set(l.join(" "));
      } // true if str is contained in this

    }, {
      key: "contains",
      value: function contains(str) {
        return this._data.indexOf(str) >= 0;
      }
    }, {
      key: "equals",
      value: function equals(str) {
        return this._data === str.toString();
      }
    }, {
      key: "ends_with",
      value: function ends_with(str) {
        var l;
        l = this._data.match(str + "$");
        return (l != null ? l.length : void 0) && l[0] === str;
      }
    }, {
      key: "deep_copy",
      value: function deep_copy() {
        return new Str(this._data + "");
      }
    }, {
      key: "_get_fs_data",
      value: function _get_fs_data(out) {
        FileSystem.set_server_id_if_necessary(out, this);
        return out.mod += "C ".concat(this._server_id, " ").concat(encodeURI(this._data), " ");
      }
    }, {
      key: "_set",
      value: function _set(value) {
        var n;

        if (value == null) {
          return this._set("");
        }

        n = value.toString();

        if (this._data !== n) {
          this._data = n;
          this.length = this._data.length;
          return true;
        }

        return false;
      }
    }, {
      key: "_get_state",
      value: function _get_state() {
        return encodeURI(this._data);
      }
    }, {
      key: "_set_state",
      value: function _set_state(str, map) {
        return this.set(decodeURIComponent(str));
      }
    }]);

    return Str;
  }(spinalCore._def["Obj"]);

  spinalCore.register_models(Str);
  root.Str = Str; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.

  root = typeof _root_obj === "undefined" ? global : window;

  TypedArray =
  /*#__PURE__*/
  function (_spinalCore$_def$Mode6) {
    _inherits(TypedArray, _spinalCore$_def$Mode6);

    // size can be
    //  - a number
    //  - a list of number
    function TypedArray(size, data) {
      var _this9;

      _classCallCheck(this, TypedArray);

      var B;
      _this9 = _possibleConstructorReturn(this, _getPrototypeOf(TypedArray).call(this)); // size

      if (size == null) {
        size = [];
      }

      if (!size.length) {
        size = [size];
      }

      _this9._size = size; // data

      if (data == null) {
        B = _this9.base_type();
        data = new B(_this9.nb_items());
      }

      _this9._data = data;
      return _this9;
    }

    _createClass(TypedArray, [{
      key: "base_type",
      value: function base_type() {} // -> to be defined by children

    }, {
      key: "dim",
      value: function dim() {
        return this._size.length;
      }
    }, {
      key: "size",
      value: function size(d) {
        if (d != null) {
          return this._size[d];
        } else {
          return this._size;
        }
      }
    }, {
      key: "set_val",
      value: function set_val(index, value) {
        index = this._get_index(index);

        if (this._data[index] !== value) {
          this._data[index] = value;
          return this._signal_change();
        }
      }
    }, {
      key: "nb_items",
      value: function nb_items() {
        var i, len, q, ref, tot;
        tot = this._size[0] || 0;
        ref = this._size.slice(1);

        for (q = 0, len = ref.length; q < len; q++) {
          i = ref[q];
          tot *= i;
        }

        return tot;
      }
    }, {
      key: "toString",
      value: function toString() {
        var i, j, l, len, m, o, q, ref, ref1, res, s, v, y;
        m = 1;
        res = "";

        l = function () {
          var len, q, ref, results;
          ref = this._size;
          results = [];

          for (q = 0, len = ref.length; q < len; q++) {
            s = ref[q];
            o = m;
            m *= s;
            results.push(o);
          }

          return results;
        }.call(this);

        ref = this._data;

        for (i = q = 0, len = ref.length; q < len; i = ++q) {
          v = ref[i];
          res += v;

          for (j = y = ref1 = l.length - 1; ref1 <= 0 ? y <= 0 : y >= 0; j = ref1 <= 0 ? ++y : --y) {
            if (i % l[j] === l[j] - 1) {
              res += [" ", "\n", "\n\n"][j];
              break;
            }
          }
        }

        return res;
      }
    }, {
      key: "equals",
      value: function equals(obj) {
        var i, len, q, ref, v;

        if (obj instanceof TypedArray) {
          if (this._size.length !== obj._size.length) {
            return false;
          }

          ref = this._size;

          for (i = q = 0, len = ref.length; q < len; i = ++q) {
            v = ref[i];

            if (v !== obj._size[i]) {
              return false;
            }
          }

          return this._data === obj._data;
        }

        return this._data === obj;
      }
    }, {
      key: "get",
      value: function get(index) {
        if (index != null) {
          return this._data[this._get_index(index)];
        } else {
          return this._data;
        }
      }
    }, {
      key: "resize",
      value: function resize(new_size) {
        var B, len, n, q, s, tot;
        tot = 1;

        for (q = 0, len = new_size.length; q < len; q++) {
          s = new_size[q];
          tot *= s;
        }

        B = this.base_type();
        n = new B(tot);
        n.set(this._data);
        this._data = n;
        this._size = new_size;
        return this._signal_change();
      }
    }, {
      key: "_set",
      value: function _set(str) {
        var B;

        if (typeof str === "string") {
          // TODO optimize
          this._set_state(str, {});

          return true;
        }

        if (this._data !== str || this._size.length !== 1 || this._size[0] !== str.length) {
          B = this.base_type();
          this._data = new B(str);
          this._size = [str.length];
          return true;
        }

        return false;
      }
    }, {
      key: "_get_index",
      value: function _get_index(index) {
        var i, m, o, q, ref;

        if (index.length) {
          o = 0;
          m = 1;

          for (i = q = 0, ref = index.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
            o += m * index[i];
            m *= this._size[i];
          }

          return o;
        }

        return index;
      }
    }, {
      key: "_get_fs_data",
      value: function _get_fs_data(out) {
        FileSystem.set_server_id_if_necessary(out, this);
        return out.mod += "C ".concat(this._server_id, " ").concat(this._get_state(), " ");
      }
    }, {
      key: "_get_state",
      value: function _get_state() {
        var d, len, len1, q, ref, ref1, res, s, y;
        res = "";
        res += this._size.length;
        ref = this._size;

        for (q = 0, len = ref.length; q < len; q++) {
          s = ref[q];
          res += "," + s;
        }

        ref1 = this._data;

        for (y = 0, len1 = ref1.length; y < len1; y++) {
          d = ref1[y];
          res += "," + d;
        }

        return res;
      }
    }, {
      key: "_set_state",
      value: function _set_state(str, map) {
        var B, l, n, q, ref, results, s, v;
        l = str.split(",");
        s = parseInt(l[0]);

        this._size = function () {
          var q, ref, results;
          results = [];

          for (v = q = 0, ref = s; 0 <= ref ? q < ref : q > ref; v = 0 <= ref ? ++q : --q) {
            results.push(parseInt(l[v + 1]));
          }

          return results;
        }();

        B = this.base_type();
        n = this.nb_items();
        this._data = new B(n);
        results = [];

        for (v = q = 0, ref = n; 0 <= ref ? q < ref : q > ref; v = 0 <= ref ? ++q : --q) {
          results.push(this._data[v] = parseFloat(l[s + 1 + v]));
        }

        return results;
      }
    }]);

    return TypedArray;
  }(spinalCore._def["Model"]);

  spinalCore.register_models(TypedArray);
  root.TypedArray = TypedArray; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.

  root = typeof _root_obj === "undefined" ? global : window;

  TypedArray_Float32 =
  /*#__PURE__*/
  function (_spinalCore$_def$Type) {
    _inherits(TypedArray_Float32, _spinalCore$_def$Type);

    function TypedArray_Float32() {
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var data = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, TypedArray_Float32);

      return _possibleConstructorReturn(this, _getPrototypeOf(TypedArray_Float32).call(this, size, data));
    }

    _createClass(TypedArray_Float32, [{
      key: "base_type",
      value: function base_type() {
        return Float32Array;
      }
    }, {
      key: "deep_copy",
      value: function deep_copy() {
        return new TypedArray_Float32(this._size, this._data);
      }
    }]);

    return TypedArray_Float32;
  }(spinalCore._def["TypedArray"]);

  spinalCore.register_models(TypedArray_Float32);
  root.TypedArray_Float32 = TypedArray_Float32; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.

  root = typeof _root_obj === "undefined" ? global : window;

  TypedArray_Float64 =
  /*#__PURE__*/
  function (_spinalCore$_def$Type2) {
    _inherits(TypedArray_Float64, _spinalCore$_def$Type2);

    function TypedArray_Float64() {
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var data = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, TypedArray_Float64);

      return _possibleConstructorReturn(this, _getPrototypeOf(TypedArray_Float64).call(this, size, data));
    }

    _createClass(TypedArray_Float64, [{
      key: "base_type",
      value: function base_type() {
        return Float64Array;
      }
    }, {
      key: "deep_copy",
      value: function deep_copy() {
        return new TypedArray_Float64(this._size, this._data);
      }
    }]);

    return TypedArray_Float64;
  }(spinalCore._def["TypedArray"]);

  spinalCore.register_models(TypedArray_Float64);
  root.TypedArray_Float64 = TypedArray_Float64; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.

  root = typeof _root_obj === "undefined" ? global : window;

  TypedArray_Int32 =
  /*#__PURE__*/
  function (_spinalCore$_def$Type3) {
    _inherits(TypedArray_Int32, _spinalCore$_def$Type3);

    function TypedArray_Int32() {
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var data = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, TypedArray_Int32);

      return _possibleConstructorReturn(this, _getPrototypeOf(TypedArray_Int32).call(this, size, data));
    }

    _createClass(TypedArray_Int32, [{
      key: "base_type",
      value: function base_type() {
        return Int32Array;
      }
    }, {
      key: "deep_copy",
      value: function deep_copy() {
        return new TypedArray_Int32(this._size, this._data);
      }
    }]);

    return TypedArray_Int32;
  }(spinalCore._def["TypedArray"]);

  spinalCore.register_models(TypedArray_Int32);
  root.TypedArray_Int32 = TypedArray_Int32; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.

  root = typeof _root_obj === "undefined" ? global : window; // Model representing a session.

  User =
  /*#__PURE__*/
  function (_spinalCore$_def$Mode7) {
    _inherits(User, _spinalCore$_def$Mode7);

    function User() {
      _classCallCheck(this, User);

      return _possibleConstructorReturn(this, _getPrototypeOf(User).call(this));
    }

    return User;
  }(spinalCore._def["Model"]);

  spinalCore.register_models(User);
  root.User = User; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // data from changed object are sent if not activity since 100ms

  root = typeof _root_obj === "undefined" ? global : window;

  FileSystem = function () {
    var XMLHttpRequest_node;

    var FileSystem =
    /*#__PURE__*/
    function () {
      function FileSystem() {
        _classCallCheck(this, FileSystem);

        // default values
        this._data_to_send = ""; // -1 means that we are waiting for a session id after a first request.

        this._session_num = -2;
        this._num_inst = FileSystem._nb_insts++;
        this.make_channel_error_timer = 0; // register this in FileSystem instances

        FileSystem._insts[this._num_inst] = this; // first, we need a session id fom the server

        if (FileSystem._userid != null) {
          this.send("U ".concat(FileSystem._userid, " ").concat(FileSystem._password, " "));
        }

        this.send("S ".concat(this._num_inst, " "));
      } // load object in $path and call $callback with the corresponding model ref


      _createClass(FileSystem, [{
        key: "load",
        value: function load(path, callback) {
          FileSystem._send_chan();

          this.send("L ".concat(FileSystem._nb_callbacks, " ").concat(encodeURI(path), " "));
          FileSystem._callbacks[FileSystem._nb_callbacks] = callback;
          return FileSystem._nb_callbacks++;
        } // load all the objects of $type

      }, {
        key: "load_type",
        value: function load_type(type, callback) {
          FileSystem._send_chan();

          this.send("R 0 ".concat(type, " "));
          return FileSystem._type_callbacks.push([type, callback]);
        } // make dir if not already present in the server. Call callback
        // as in the @load proc -- when done (i.e. when loaded or created)

      }, {
        key: "load_or_make_dir",
        value: function load_or_make_dir(dir, callback) {
          var _this10 = this;

          return this.load(dir, function (res, err) {
            var lst, nir, oir, v;

            if (err) {
              if (dir === "/") {
                return callback(0, err);
              } else {
                lst = function () {
                  var len, q, ref, results;
                  ref = dir.split('/');
                  results = [];

                  for (q = 0, len = ref.length; q < len; q++) {
                    v = ref[q];

                    if (v.length) {
                      results.push(v);
                    }
                  }

                  return results;
                }();

                nir = lst.pop();
                oir = "/" + lst.join("/");
                return _this10.load_or_make_dir(oir, function (n_res, n_err) {
                  var n_dir;

                  if (n_err) {
                    return callback(0, n_err);
                  } else {
                    n_dir = new Directory();
                    n_res.add_file(nir, n_dir);
                    return callback(n_dir, n_err);
                  }
                });
              }
            } else {
              return callback(res, err);
            }
          });
        } // load an object using is pointer and call $callback with the corresponding ref

      }, {
        key: "load_ptr",
        value: function load_ptr(ptr, callback) {
          FileSystem._send_chan();

          this.send("l ".concat(FileSystem._nb_callbacks, " ").concat(ptr, " "));
          FileSystem._callbacks[FileSystem._nb_callbacks] = callback;
          return FileSystem._nb_callbacks++;
        }
      }, {
        key: "load_right",
        value: function load_right(ptr, callback) {
          FileSystem._send_chan();

          this.send("r ".concat(ptr, " ").concat(FileSystem._nb_callbacks, " "));
          FileSystem._callbacks[FileSystem._nb_callbacks] = callback;
          return FileSystem._nb_callbacks++;
        }
      }, {
        key: "share_model",
        value: function share_model(ptr, file_name, share_type, targetName) {
          FileSystem._send_chan();

          return this.send("h ".concat(ptr._server_id, " ").concat(share_type, " ").concat(encodeURI(targetName), " ").concat(encodeURI(file_name), " "));
        } // explicitly send a command

      }, {
        key: "send",
        value: function send(data) {
          this._data_to_send += data;

          if (FileSystem._timer_send == null) {
            return FileSystem._timer_send = setTimeout(FileSystem._timeout_send_func, 1);
          }
        } // send a request for a "push" channel

      }, {
        key: "make_channel",
        value: function make_channel() {
          var path, xhr_object;
          path = "";

          if (FileSystem.CONNECTOR_TYPE === "Node" || FileSystem.is_cordova) {
            if (FileSystem._port) {
              path = "http://" + FileSystem._url + ":" + FileSystem._port + FileSystem.url_com + "?s=".concat(this._session_num);
            } else {
              path = "http://" + FileSystem._url + FileSystem.url_com + "?s=".concat(this._session_num);
            }
          } else if (FileSystem.CONNECTOR_TYPE === "Browser") {
            path = FileSystem.url_com + "?s=".concat(this._session_num);
          }

          xhr_object = FileSystem._my_xml_http_request();
          xhr_object.open('GET', path, true);

          xhr_object.onreadystatechange = function () {
            var _fs, _w;

            if (this.readyState === 4 && this.status === 200) {
              _fs = FileSystem.get_inst();

              if (_fs.make_channel_error_timer !== 0) {
                _fs.onConnectionError(0);
              }

              _fs.make_channel_error_timer = 0;

              if (FileSystem._disp) {
                console.log("chan ->", this.responseText);
              }

              _w = function _w(sid, obj) {
                var _obj, c, len, mod_R, q, ref, results;

                _obj = FileSystem._create_model_by_name(obj);

                if (sid != null && _obj != null) {
                  _obj._server_id = sid;
                  FileSystem._objects[sid] = _obj;
                  ref = FileSystem._type_callbacks;
                  results = [];

                  for (q = 0, len = ref.length; q < len; q++) {
                    c = ref[q];
                    mod_R = root[c[0]] || spinalCore._def[c[0]];

                    if (_obj instanceof mod_R) {
                      results.push(c[1](_obj));
                    } else {
                      results.push(void 0);
                    }
                  }

                  return results;
                }
              };

              FileSystem._sig_server = false;
              eval(this.responseText);
              return FileSystem._sig_server = true;
            } else if (this.readyState === 4 && this.status === 0) {
              console.error("Disconnected from the server with request : ".concat(path, "."));
              _fs = FileSystem.get_inst();

              if (_fs.make_channel_error_timer === 0) {
                //first disconnect
                console.log("Trying to reconnect.");
                _fs.make_channel_error_timer = new Date();
                setTimeout(_fs.make_channel.bind(_fs), 1000);
                return _fs.onConnectionError(1);
              } else if (new Date() - _fs.make_channel_error_timer < FileSystem._timeout_reconnect) {
                // under timeout
                return setTimeout(_fs.make_channel.bind(_fs), 1000); // timeout reached
              } else {
                return _fs.onConnectionError(2);
              }
            } else if (this.readyState === 4 && this.status === 500) {
              return FileSystem.get_inst().onConnectionError(3);
            }
          };

          return xhr_object.send();
        } // default callback on make_channel error after the timeout disconnected reached
        // This method can be surcharged.
        // error_code :
        // 0 = Error resolved
        // 1 = 1st disconnection
        // 2 = disconnection timeout
        // 3 = Server went down Reinit everything
        // 4 = Server down on connection

      }, {
        key: "onConnectionError",
        value: function onConnectionError(error_code) {
          var msg;
          msg = "";

          if (error_code === 0) {
            // Error resolved
            if (FileSystem.CONNECTOR_TYPE === "Browser" || FileSystem.is_cordova) {
              FileSystem.popup.hide();
            } else {
              console.log("Reconnected to the server.");
            }
          } else if (error_code === 1) {
            // 1st disconnection
            if (FileSystem.CONNECTOR_TYPE === "Browser" || FileSystem.is_cordova) {
              msg = "Disconnected from the server, trying to reconnect...";
            } else {
              console.error("Disconnected from the server, trying to reconnect...");
            }
          } else if (error_code === 2 || error_code === 3 || error_code === 4) {
            if (FileSystem.CONNECTOR_TYPE === "Browser" || FileSystem.is_cordova) {
              msg = "Disconnected from the server, please refresh the window.";
            } else if (FileSystem.CONNECTOR_TYPE === "Node") {
              console.error("Disconnected from the server.");
              process.exit();
            } else {
              console.error("Disconnected from the server.");
            }
          }

          if (msg !== "") {
            if (FileSystem.popup === 0) {
              FileSystem.popup = new new_alert_msg({
                parent: document.getElementsByTagName("BODY")[0],
                msg: msg,
                btn: [{
                  txt: 'reload page',
                  click: window.location.reload.bind(window.location),
                  backgroundColor: '#ff5b57'
                }, {
                  txt: 'close',
                  backgroundColor: '#348fe2',
                  click: function click() {
                    return FileSystem.popup.hide();
                  }
                }]
              });
            } else {
              FileSystem.popup.show();
            }

            if (error_code === 2 || error_code === 3 || error_code === 4) {
              FileSystem.popup.show_btn();
            } else {
              FileSystem.popup.hide_btn();
            }

            return FileSystem.popup.setMsg(msg);
          }
        } // get the first running inst

      }], [{
        key: "get_inst",
        value: function get_inst() {
          var i, k, ref;
          ref = FileSystem._insts;

          for (k in ref) {
            i = ref[k];
            return i;
          }

          return new FileSystem();
        }
      }, {
        key: "set_server_id_if_necessary",
        value: function set_server_id_if_necessary(out, obj) {
          var ncl;

          if (obj._server_id == null) {
            // registering
            obj._server_id = FileSystem._get_new_tmp_server_id();
            FileSystem._tmp_objects[obj._server_id] = obj; // new object

            ncl = ModelProcessManager.get_object_class(obj);

            if (obj._underlying_fs_type != null) {
              out.mod += "T ".concat(obj._server_id, " ").concat(ncl, " ");
              ncl = obj._underlying_fs_type();
            }

            out.cre += "N ".concat(obj._server_id, " ").concat(ncl, " "); // data

            return obj._get_fs_data(out);
          }
        } // send changes of m to instances.

      }, {
        key: "signal_change",
        value: function signal_change(m) {
          if (FileSystem._sig_server) {
            FileSystem._objects_to_send[m.model_id] = m;

            if (FileSystem._timer_chan != null) {
              clearTimeout(FileSystem._timer_chan);
            }

            return FileSystem._timer_chan = setTimeout(FileSystem._timeout_chan_func, 250);
          }
        }
      }, {
        key: "_tmp_id_to_real",
        value: function _tmp_id_to_real(tmp_id, res) {
          var fs, path, ptr, tmp, xhr_object;
          tmp = FileSystem._tmp_objects[tmp_id];

          if (tmp == null) {
            console.log(tmp_id);
          }

          FileSystem._objects[res] = tmp;
          tmp._server_id = res;
          delete FileSystem._tmp_objects[tmp_id];
          ptr = FileSystem._ptr_to_update[tmp_id];

          if (ptr != null) {
            delete FileSystem._ptr_to_update[tmp_id];
            ptr.data.value = res;
          }

          if (FileSystem._files_to_upload[tmp_id] != null && tmp.file != null) {
            delete FileSystem._files_to_upload[tmp_id]; // send the file

            fs = FileSystem.get_inst();
            path = "";

            if (FileSystem.CONNECTOR_TYPE === "Node" || FileSystem.is_cordova) {
              if (FileSystem._port) {
                path = "http://" + FileSystem._url + ":" + FileSystem._port + FileSystem.url_com + "?s=".concat(fs._session_num, "&p=").concat(tmp._server_id);
              } else {
                path = "http://" + FileSystem._url + FileSystem.url_com + "?s=".concat(fs._session_num, "&p=").concat(tmp._server_id);
              }
            } else if (FileSystem.CONNECTOR_TYPE === "Browser") {
              path = FileSystem.url_com + "?s=".concat(fs._session_num, "&p=").concat(tmp._server_id);
            }

            xhr_object = FileSystem._my_xml_http_request();
            xhr_object.open('PUT', path, true);

            xhr_object.onreadystatechange = function () {
              var _w;

              if (this.readyState === 4 && this.status === 200) {
                _w = function _w(sid, obj) {
                  var _obj;

                  _obj = FileSystem._create_model_by_name(obj);

                  if (sid != null && _obj != null) {
                    _obj._server_id = sid;
                    return FileSystem._objects[sid] = _obj;
                  }
                };

                return eval(this.responseText);
              }
            };

            xhr_object.send(tmp.file);
            delete tmp.file;
          }

          return FileSystem.signal_change(FileSystem._objects[res]);
        }
      }, {
        key: "_create_model_by_name",
        value: function _create_model_by_name(name) {
          if (typeof name !== "string") {
            return name;
          }

          if (typeof spinalCore._def[name] !== 'undefined') {
            return new spinalCore._def[name]();
          }

          if (typeof root[name] === 'undefined') {
            if (FileSystem.debug === true) {
              console.warn("Got Model type \"".concat(name, "\" from hub but not registered."));
            }

            root[name] = new Function("return class ".concat(name, " extends spinalCore._def[\"Model\"] {}"))();
          }

          return new root[name]();
        }
      }, {
        key: "extend",
        value: function extend(child, parent) {
          var child_name, ctor, key, value;

          for (key in parent) {
            value = parent[key];
            child[key] = value;
          }

          ctor = function ctor() {
            this.constructor = child;
          };

          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;

          child.super = function () {
            var args = [];

            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }

            child.__super__.constructor.apply(arguments[0], args); // using embedded javascript because the word 'super' is reserved

          };

          root = typeof global !== "undefined" && global !== null ? global : window;
          child_name = /^(function|class)\s+([\w\$]+)\s*\(/.exec(child.toString())[1];
          return root[child_name] = child;
        }
      }, {
        key: "_get_new_tmp_server_id",
        value: function _get_new_tmp_server_id() {
          FileSystem._cur_tmp_server_id++;

          if (FileSystem._cur_tmp_server_id % 4 === 0) {
            FileSystem._cur_tmp_server_id++;
          }

          return FileSystem._cur_tmp_server_id;
        } // send changes

      }, {
        key: "_send_chan",
        value: function _send_chan() {
          var f, k, out, ref, results;
          out = FileSystem._get_chan_data();
          ref = FileSystem._insts;
          results = [];

          for (k in ref) {
            f = ref[k];
            results.push(f.send(out));
          }

          return results;
        } // timeout for at least one changed object

      }, {
        key: "_timeout_chan_func",
        value: function _timeout_chan_func() {
          FileSystem._send_chan();

          return delete FileSystem._timer_chan;
        } // get data of objects to send

      }, {
        key: "_get_chan_data",
        value: function _get_chan_data() {
          var model, n, out, ref;
          out = {
            cre: "",
            mod: ""
          };
          ref = FileSystem._objects_to_send;

          for (n in ref) {
            model = ref[n];

            model._get_fs_data(out);
          }

          FileSystem._objects_to_send = {};
          return out.cre + out.mod;
        }
      }, {
        key: "_timeout_send_func",
        value: function _timeout_send_func() {
          var f, k, out, path, ref, ref1, xhr_object; // if some model have changed, we have to send the changes now

          out = FileSystem._get_chan_data();
          ref = FileSystem._insts;

          for (k in ref) {
            f = ref[k];
            f._data_to_send += out;
          }

          ref1 = FileSystem._insts; // send data

          for (k in ref1) {
            f = ref1[k];

            if (!f._data_to_send.length) {
              continue;
            } // if we are waiting for a session id, do not send the data
            // (@responseText will contain another call to @_timeout_send with the session id)


            if (f._session_num === -1) {
              continue;
            } // for first call, do not add the session id (but say that we are waiting for one)


            if (f._session_num === -2) {
              f._session_num = -1;
            } else {
              f._data_to_send = "s ".concat(f._session_num, " ") + f._data_to_send;
            } // request


            path = "";

            if (FileSystem.CONNECTOR_TYPE === "Node" || FileSystem.is_cordova) {
              if (FileSystem._port) {
                path = "http://" + FileSystem._url + ":" + FileSystem._port + FileSystem.url_com;
              } else {
                path = "http://" + FileSystem._url + FileSystem.url_com;
              }
            } else if (FileSystem.CONNECTOR_TYPE === "Browser") {
              path = FileSystem.url_com;
            }

            xhr_object = FileSystem._my_xml_http_request();
            xhr_object.open('POST', path, true);

            xhr_object.onreadystatechange = function () {
              var _c, _w, c, len, q, results;

              if (this.readyState === 4 && this.status === 200) {
                if (FileSystem._disp) {
                  console.log("resp ->", this.responseText);
                }

                _c = []; // callbacks

                _w = function _w(sid, obj) {
                  var _obj, c, len, mod_R, q, ref2, results;

                  _obj = FileSystem._create_model_by_name(obj);

                  if (sid != null && _obj != null) {
                    _obj._server_id = sid;
                    FileSystem._objects[sid] = _obj;
                    ref2 = FileSystem._type_callbacks;
                    results = [];

                    for (q = 0, len = ref2.length; q < len; q++) {
                      c = ref2[q];
                      mod_R = root[c[0]] || spinalCore._def[c[0]];

                      if (_obj instanceof mod_R) {
                        results.push(c[1](_obj));
                      } else {
                        results.push(void 0);
                      }
                    }

                    return results;
                  }
                };

                FileSystem._sig_server = false;
                eval(this.responseText);
                FileSystem._sig_server = true;
                results = [];

                for (q = 0, len = _c.length; q < len; q++) {
                  c = _c[q];
                  results.push(FileSystem._callbacks[c[0]](FileSystem._objects[c[1]], c[2]));
                }

                return results;
              } else if (this.readyState === 4 && (this.status === 0 || this.status === 500)) {
                return FileSystem.get_inst().onConnectionError(4);
              }
            };

            if (FileSystem._disp) {
              console.log("sent ->", f._data_to_send + "E ");
            }

            xhr_object.setRequestHeader('Content-Type', 'text/plain');
            xhr_object.send(f._data_to_send + "E "); //console.log "-> ", f._data_to_send

            f._data_to_send = "";
          }

          FileSystem._objects_to_send = {};
          return delete FileSystem._timer_send;
        }
      }, {
        key: "_my_xml_http_request",
        value: function _my_xml_http_request() {
          if (FileSystem.CONNECTOR_TYPE === "Browser") {
            if (window.XMLHttpRequest) {
              return new XMLHttpRequest();
            }

            if (window.ActiveXObject) {
              return new ActiveXObject('Microsoft.XMLHTTP');
            }

            return alert('Your browser does not seem to support XMLHTTPRequest objects...');
          } else if (FileSystem.CONNECTOR_TYPE === "Node") {
            return new FileSystem._XMLHttpRequest();
          } else {
            return console.log("you must define CONNECTOR_TYPE");
          }
        }
      }]);

      return FileSystem;
    }();

    ; // when object are saved, their _server_id is assigned to a tmp value

    FileSystem.popup = 0;
    FileSystem.debug = false;
    FileSystem._cur_tmp_server_id = 0;
    FileSystem._sig_server = true; // if changes has to be sent

    FileSystem._disp = false;
    FileSystem._userid = "644";
    FileSystem._timeout_reconnect = 30000;

    if (typeof document !== "undefined") {
      FileSystem.is_cordova = document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1;
    } else {
      FileSystem.is_cordova = false;
    } //     if ( @is_cordova )
    //         // PhoneGap application
    //     else
    //         // Web page
    // TODO: Hardcoded: review this


    if (typeof global !== 'undefined') {
      XMLHttpRequest_node = require('xhr2');
      FileSystem._XMLHttpRequest = XMLHttpRequest_node;
    } // data are sent after a timeout (and are concatened before)


    FileSystem._objects_to_send = {};
    FileSystem._timer_send = void 0;
    FileSystem._timer_chan = void 0; // functions to be called after an answer

    FileSystem._nb_callbacks = 0;
    FileSystem._callbacks = {};
    FileSystem._type_callbacks = []; // list of callbacks associated to a type: [ [ "type", function ], ... ]
    // instances of FileSystem

    FileSystem._nb_insts = 0;
    FileSystem._insts = {}; // ..._server_id -> object

    FileSystem._files_to_upload = {}; // ref to Path waiting to be registered before sending data

    FileSystem._ptr_to_update = {}; // Ptr objects that need an update, associated with @_tmp_objects

    FileSystem._tmp_objects = {}; // objects waiting for a real _server_id

    FileSystem._objects = {}; // _server_id -> object
    // url and port of the server

    FileSystem._url = "127.0.0.1";
    FileSystem._port = "8888";
    FileSystem.url_com = "/sceen/_";
    FileSystem.url_upload = "/sceen/upload"; // conector type : Browser or Node

    if (typeof global !== 'undefined') {
      FileSystem.CONNECTOR_TYPE = "Node";
    } else {
      FileSystem.CONNECTOR_TYPE = "Browser";
    }

    return FileSystem;
  }.call(this);

  spinalCore.register_models(FileSystem);
  root.FileSystem = FileSystem; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // List of files
  // _underlying_fs_type is not needed ()

  root = typeof _root_obj === "undefined" ? global : window;

  Directory =
  /*#__PURE__*/
  function (_spinalCore$_def$Lst2) {
    _inherits(Directory, _spinalCore$_def$Lst2);

    function Directory() {
      _classCallCheck(this, Directory);

      return _possibleConstructorReturn(this, _getPrototypeOf(Directory).call(this));
    }

    _createClass(Directory, [{
      key: "base_type",
      value: function base_type() {
        return File;
      }
    }, {
      key: "find",
      value: function find(name) {
        var f, len, q, ref;
        ref = this;

        for (q = 0, len = ref.length; q < len; q++) {
          f = ref[q];

          if (f.name.equals(name)) {
            return f;
          }
        }

        return void 0;
      }
    }, {
      key: "load",
      value: function load(name, callback) {
        var f;
        f = this.find(name);

        if (f) {
          return f.load(callback);
        } else {
          return callback(void 0, "file does not exist");
        }
      }
    }, {
      key: "has",
      value: function has(name) {
        var f, len, q, ref;
        ref = this;

        for (q = 0, len = ref.length; q < len; q++) {
          f = ref[q];

          if (f.name.equals(name)) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "add_file",
      value: function add_file(name, obj) {
        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var o, res;
        o = this.find(name);

        if (o != null) {
          return o;
        }

        res = new File(name, obj, params);
        this.push(res);
        return res;
      }
    }, {
      key: "add_tiff_file",
      value: function add_tiff_file(name, obj, tiff_obj) {
        var params = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var o, res;
        o = this.find(name);

        if (o != null) {
          return o;
        }

        res = new TiffFile(name, obj, tiff_obj, params);
        this.push(res);
        return res;
      }
    }, {
      key: "force_add_file",
      value: function force_add_file(name, obj) {
        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var name_file, num, o, res;
        num = 0;
        name_file = name;
        o = this.find(name_file);

        if (o != null) {
          while (true) {
            name_file = name + "_" + num;
            o = this.find(name_file);

            if (o != null) {
              num += 1;
            } else {
              break;
            }
          }
        }

        res = new File(name_file, obj, params);
        this.push(res);
        return res;
      }
    }, {
      key: "get_file_info",
      value: function get_file_info(info) {
        return info.icon = "folder";
      }
    }]);

    return Directory;
  }(spinalCore._def["Lst"]);

  spinalCore.register_models(Directory);
  root.Directory = Directory; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.

  root = typeof _root_obj === "undefined" ? global : window;

  File =
  /*#__PURE__*/
  function (_spinalCore$_def$Mode8) {
    _inherits(File, _spinalCore$_def$Mode8);

    function File() {
      var _this11;

      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      var ptr_or_model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var info = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      _classCallCheck(this, File);

      var cp_info, key, val;
      _this11 = _possibleConstructorReturn(this, _getPrototypeOf(File).call(this));
      cp_info = {};

      for (key in info) {
        val = info[key];
        cp_info[key] = val;
      }

      if (ptr_or_model instanceof Model) {
        if (cp_info.model_type == null) {
          cp_info.model_type = ModelProcessManager.get_object_class(ptr_or_model);
        }

        if (typeof ptr_or_model.get_file_info === "function") {
          ptr_or_model.get_file_info(cp_info);
        }
      }

      _this11.add_attr({
        name: name,
        admins: new Lst(),
        users: new Lst(),
        _created_at: new Date(),
        _ptr: new Ptr(ptr_or_model),
        _info: cp_info
      });

      return _this11;
    } // -> img: "data/base64...."
    // -> icon: "toto"
    // -> model_type: "Directory"...
    // -> remaining
    // -> to_upload


    _createClass(File, [{
      key: "load",
      value: function load(callback) {
        return this._ptr.load(callback);
      }
    }]);

    return File;
  }(spinalCore._def["Model"]); //     drop: ( evt, info ) ->
  //         @handleFiles evt, info
  //         evt.returnValue = false
  //         evt.stopPropagation()
  //         evt.preventDefault()
  //         return false
  //     handleFiles: (event, info, files) ->
  //         if typeof files == "undefined" #Drag and drop
  //             event.stopPropagation()
  //             event.returnValue = false
  //             event.preventDefault()
  //             files = event.dataTransfer.files
  //         if event.dataTransfer.files.length > 0
  //             for file in files
  //                 format = file.type.indexOf "image"
  //                 if format isnt -1
  //                     pic = new ImgItem file.name
  //                     accept_child = info.item.accept_child pic
  //                     if accept_child == true
  //                         info.item.add_child pic
  //                         info.item.img_collection.push pic
  //             @sendFiles()
  // TreeView.default_types.push ( evt, info ) ->
  //     d = new Directory
  //     d.drop evt, info


  spinalCore.register_models(File);
  root.File = File; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // contains (privately on the server) a path to data on the server

  root = typeof _root_obj === "undefined" ? global : window;

  Path =
  /*#__PURE__*/
  function (_spinalCore$_def$Mode9) {
    _inherits(Path, _spinalCore$_def$Mode9);

    // @file is optionnal. Must be a javascript File object
    function Path(file1) {
      var _this12;

      _classCallCheck(this, Path);

      var size;
      _this12 = _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this));
      _this12.file = file1;
      size = _this12.file != null ? _this12.file.fileSize != null ? _this12.file.fileSize : _this12.file.size : 0;

      _this12.add_attr({
        remaining: size,
        to_upload: size
      });

      return _this12;
    }

    _createClass(Path, [{
      key: "get_file_info",
      value: function get_file_info(info) {
        info.remaining = this.remaining;
        return info.to_upload = this.to_upload;
      }
    }, {
      key: "_get_fs_data",
      value: function _get_fs_data(out) {
        _get(_getPrototypeOf(Path.prototype), "_get_fs_data", this).call(this, out); // permit to send the data after the server's answer


        if (this.file != null && this._server_id & 3) {
          return FileSystem._files_to_upload[this._server_id] = this;
        }
      }
    }]);

    return Path;
  }(spinalCore._def["Model"]);

  spinalCore.register_models(Path);
  root.Path = Path; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // contains an id of a model on the server

  root = typeof _root_obj === "undefined" ? global : window;

  Ptr =
  /*#__PURE__*/
  function (_spinalCore$_def$Mode10) {
    _inherits(Ptr, _spinalCore$_def$Mode10);

    // model may be a number (the pointer)
    function Ptr(model) {
      var _this13;

      _classCallCheck(this, Ptr);

      _this13 = _possibleConstructorReturn(this, _getPrototypeOf(Ptr).call(this));
      _this13.data = {};

      _this13._set(model);

      return _this13;
    }

    _createClass(Ptr, [{
      key: "load",
      value: function load(callback) {
        var ref;

        if (this.data.model != null) {
          return callback(this.data.model, false);
        } else {
          return (ref = FileSystem.get_inst()) != null ? ref.load_ptr(this.data.value, callback) : void 0;
        }
      }
    }, {
      key: "_get_fs_data",
      value: function _get_fs_data(out) {
        FileSystem.set_server_id_if_necessary(out, this);

        if (this.data.model != null) {
          FileSystem.set_server_id_if_necessary(out, this.data.model);
          out.mod += "C ".concat(this._server_id, " ").concat(this.data.model._server_id, " ");
          this.data.value = this.data.model._server_id;

          if (this.data.model._server_id & 3) {
            return FileSystem._ptr_to_update[this.data.model._server_id] = this;
          }
        } else {
          return out.mod += "C ".concat(this._server_id, " ").concat(this.data.value, " ");
        }
      }
    }, {
      key: "_set",
      value: function _set(model) {
        var res;

        if (typeof model === "number") {
          res = this.data.value !== model;
          this.data = {
            value: model
          };
          return res;
        }

        if (model instanceof Model) {
          res = this.data.value !== model._server_id;
          this.data = {
            model: model,
            value: model._server_id
          };
          return res;
        }

        return false;
      }
    }, {
      key: "_get_state",
      value: function _get_state() {
        return this._data;
      }
    }, {
      key: "_set_state",
      value: function _set_state(str, map) {
        return this.set(str);
      }
    }]);

    return Ptr;
  }(spinalCore._def["Model"]);

  spinalCore.register_models(Ptr);
  root.Ptr = Ptr; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.

  root = typeof _root_obj === "undefined" ? global : window; // Model representing a RightsItem.

  RightsItem =
  /*#__PURE__*/
  function (_spinalCore$_def$Lst3) {
    _inherits(RightsItem, _spinalCore$_def$Lst3);

    function RightsItem() {
      _classCallCheck(this, RightsItem);

      return _possibleConstructorReturn(this, _getPrototypeOf(RightsItem).call(this));
    }

    return RightsItem;
  }(spinalCore._def["Lst"]);

  spinalCore.register_models(RightsItem);
  root.RightsItem = RightsItem; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.

  root = typeof _root_obj === "undefined" ? global : window; // Model representing a session.

  SessionModel =
  /*#__PURE__*/
  function (_spinalCore$_def$Mode11) {
    _inherits(SessionModel, _spinalCore$_def$Mode11);

    function SessionModel() {
      _classCallCheck(this, SessionModel);

      return _possibleConstructorReturn(this, _getPrototypeOf(SessionModel).call(this));
    }

    return SessionModel;
  }(spinalCore._def["Model"]); // default
  // @add_attr
  //   id : 0                # user_id
  //   timestamp: 0          # timestamp of the last change or make_channel
  //   type: "Session type"  # type of the session e.g. HTTTP_JavaScript
  //   actif: true           # state of the session true/false


  spinalCore.register_models(SessionModel);
  root.SessionModel = SessionModel; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.

  root = typeof _root_obj === "undefined" ? global : window;

  TiffFile =
  /*#__PURE__*/
  function (_spinalCore$_def$File) {
    _inherits(TiffFile, _spinalCore$_def$File);

    function TiffFile() {
      var _this14;

      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      var ptr_or_model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var ptr_tiff = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var info = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      _classCallCheck(this, TiffFile);

      _this14 = _possibleConstructorReturn(this, _getPrototypeOf(TiffFile).call(this, name, ptr_or_model, info));

      _this14.add_attr({
        _ptr_tiff: new Ptr(ptr_tiff),
        _has_been_converted: 0
      });

      return _this14;
    }

    _createClass(TiffFile, [{
      key: "load_tiff",
      value: function load_tiff(callback) {
        return this._ptr_tiff.load(callback);
      }
    }]);

    return TiffFile;
  }(spinalCore._def["File"]);

  spinalCore.register_models(TiffFile);
  root.TiffFile = TiffFile; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.

  root = typeof _root_obj === "undefined" ? global : window; // Model representing a UserRight.

  UserRight =
  /*#__PURE__*/
  function (_spinalCore$_def$Mode12) {
    _inherits(UserRight, _spinalCore$_def$Mode12);

    function UserRight() {
      _classCallCheck(this, UserRight);

      return _possibleConstructorReturn(this, _getPrototypeOf(UserRight).call(this));
    }

    _createClass(UserRight, [{
      key: "set",
      value: function set() {
        return console.log("Set a UserRight is not allowed.");
      }
    }]);

    return UserRight;
  }(spinalCore._def["Model"]);

  spinalCore.register_models(UserRight);
  root.UserRight = UserRight; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.

  root = typeof _root_obj === "undefined" ? global : window; // Model representing a RightSetList.

  RightSetList =
  /*#__PURE__*/
  function (_spinalCore$_def$Lst4) {
    _inherits(RightSetList, _spinalCore$_def$Lst4);

    function RightSetList() {
      _classCallCheck(this, RightSetList);

      return _possibleConstructorReturn(this, _getPrototypeOf(RightSetList).call(this));
    }

    return RightSetList;
  }(spinalCore._def["Lst"]);

  spinalCore.register_models(RightSetList);
  root.RightSetList = RightSetList; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // something which has to be synchronized with one or several model(s)
  // Each process has an uniquer id called "process_id"

  root = typeof _root_obj === "undefined" ? global : window;

  Process =
  /*#__PURE__*/
  function () {
    // m can be a model or a list of models
    function Process(m) {
      var onchange_construction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      _classCallCheck(this, Process);

      var i, len, q;
      this.process_id = ModelProcessManager._cur_process_id;
      ModelProcessManager._cur_process_id += 1; // what this is observing

      this._models = []; // bind

      if (m instanceof Model) {
        m.bind(this, onchange_construction);
      } else if (m.length != null) {
        for (q = 0, len = m.length; q < len; q++) {
          i = m[q];
          i.bind(this, onchange_construction);
        }
      } else if (m != null) {
        console.error("Process constructor doesn't know what to do with", m);
      }
    }

    _createClass(Process, [{
      key: "destructor",
      value: function destructor() {
        var i, len, m, q, ref, results;
        ref = this._models;
        results = [];

        for (q = 0, len = ref.length; q < len; q++) {
          m = ref[q];
          i = m._processes.indexOf(this);

          if (i >= 0) {
            results.push(m._processes.splice(i, 1));
          } else {
            results.push(void 0);
          }
        }

        return results;
      } // called if at least one of the corresponding models has changed in the previous round

    }, {
      key: "onchange",
      value: function onchange() {}
    }]);

    return Process;
  }(); // bind model or list of model to function or process f
  // (simply call the bind method of Model)


  root.bind = function (m, f) {
    var i, len, q, results;

    if (m instanceof Model) {
      return m.bind(f);
    } else {
      results = [];

      for (q = 0, len = m.length; q < len; q++) {
        i = m[q];
        results.push(i.bind(f));
      }

      return results;
    }
  };

  spinalCore.register_models(Process);
  root.Process = Process; // Copyright 2015 SpinalCom - www.spinalcom.com
  // This file is part of SpinalCore.
  // Please read all of the following terms and conditions
  // of the Free Software license Agreement ("Agreement")
  // carefully.
  // This Agreement is a legally binding contract between
  // the Licensee (as defined below) and SpinalCom that
  // sets forth the terms and conditions that govern your
  // use of the Program. By installing and/or using the
  // Program, you agree to abide by all the terms and
  // conditions stated or referenced herein.
  // If you do not agree to abide by these terms and
  // conditions, do not demonstrate your acceptance and do
  // not install or use the Program.
  // You should have received a copy of the license along
  // with this file. If not, see
  // <http://resources.spinalcom.com/licenses.pdf>.
  // permits to bind a function to a model
  // f is the function which has to be binded
  // onchange_construction true means that onchange will be automatically called after after the bind

  root = typeof _root_obj === "undefined" ? global : window;

  BindProcess =
  /*#__PURE__*/
  function (_spinalCore$_def$Proc) {
    _inherits(BindProcess, _spinalCore$_def$Proc);

    function BindProcess(model, onchange_construction, f1) {
      var _this15;

      _classCallCheck(this, BindProcess);

      _this15 = _possibleConstructorReturn(this, _getPrototypeOf(BindProcess).call(this, model, onchange_construction));
      _this15.f = f1;
      return _this15;
    }

    _createClass(BindProcess, [{
      key: "onchange",
      value: function onchange() {
        return this.f();
      }
    }]);

    return BindProcess;
  }(spinalCore._def["Process"]);

  spinalCore.register_models(BindProcess);
  root.BindProcess = BindProcess; // Copyright 2015 SpinalCom  www.spinalcom.com
  // This file is part of SpinalCore.
  // SpinalCore is free software: you can redistribute it and/or modify
  // it under the terms of the GNU Lesser General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.
  // SpinalCore is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU Lesser General Public License for more details.
  // You should have received a copy of the GNU General Public License
  // along with SpinalCore. If not, see <http://www.gnu.org/licenses/>.

  root = typeof _root_obj === "undefined" ? global : window; // create a new dom element
  //  nodeName to specify kind (div by default)
  //  parentNode to specify a parent
  //  style { ... }
  //  txt for a text node as a child
  //  other paramers are used to set directly set attributes

  root.new_dom_element = function () {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var nodeName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "div";
    var k, n, name, v, val;
    n = document.createElement(params.nodeName || nodeName);

    for (name in params) {
      val = params[name];

      switch (name) {
        case "parentNode":
          val.appendChild(n);
          break;

        case "nodeName":
          void 0;
          break;

        case "style":
          for (k in val) {
            v = val[k];
            n.style[k] = v;
          }

          break;

        case "txt":
          //r = new RegExp " ", "g"
          //n.appendChild document.createTextNode val.replace r, "\u00a0"
          n.innerHTML = val;
          break;

        default:
          n[name] = val;
      }
    }

    return n;
  }; // obj is a DOM object. src is a string or an array of
  //  string containing one or several classNames separated with spaces


  root.add_class = function (obj, src) {
    var old, p_1;

    if (typeof src === "string") {
      return add_class(obj, src.split(" "));
    }

    old = (obj.className || "").split(" ");
    p_1 = src.filter(function (x) {
      return indexOf.call(old, x) < 0;
    });
    return obj.className = old.concat(p_1).filter(function (x) {
      return x;
    }).join(" ");
  }; // obj is a DOM object. src is a string or an array of string
  //  containing one or several classNames separated with spaces


  root.rem_class = function (obj, src) {
    var old;

    if (typeof src === "string") {
      return rem_class(obj, src.split(" "));
    }

    old = (obj.className || "").split(" ");
    return obj.className = old.filter(function (x) {
      return indexOf.call(src, x) < 0;
    }).join(" ");
  }; // real position of an object


  root.get_left = function (l) {
    if (l.offsetParent != null) {
      return l.offsetLeft + get_left(l.offsetParent);
    } else {
      return l.offsetLeft;
    }
  }; // real position of an object


  root.get_top = function (l) {
    if (l.offsetParent != null) {
      return l.offsetTop + get_top(l.offsetParent);
    } else {
      return l.offsetTop;
    }
  }; // make msg popup
  // params:
  //   parent
  //   onclose
  //   title
  //   msg


  root.new_alert_msg =
  /*#__PURE__*/
  function () {
    function new_alert_msg() {
      var params1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, new_alert_msg);

      this.create_footer = this.create_footer.bind(this);
      this.params = params1;
      this.rotatating = true;
      this.deg = 40;
      this.in_rotation = false;
      this.background = new_dom_element({
        nodeName: 'div',
        style: {
          position: 'fixed',
          height: '100%',
          width: '100%',
          top: 0,
          left: 0,
          backgroundColor: 'rgba(36, 42, 48, 0.38)',
          zIndex: 100000,
          textAlign: 'center'
        },
        onclick: function onclick(evt) {
          if (evt.target !== this.background) {
            return;
          }

          if (this.params.onclose != null) {
            this.params.onClose();
          }

          this.hide();

          if (typeof evt.stopPropagation === "function") {
            evt.stopPropagation();
          }

          if (typeof evt.preventDefault === "function") {
            evt.preventDefault();
          }

          if (typeof evt.stopImmediatePropagation === "function") {
            evt.stopImmediatePropagation();
          }

          return false;
        }
      });

      if (this.params.parent != null) {
        this.params.parent.appendChild(this.background);
      }

      this.popup = new_dom_element({
        nodeName: 'div',
        style: {
          marginTop: '30px',
          display: 'inline-block',
          width: '80%',
          backgroundColor: '#FFF',
          zIndex: 100001,
          borderRadius: '30px'
        }
      });
      this.background.appendChild(this.popup); // @create_header()

      this.create_content();
      this.create_footer();
    } // @content = new_dom_element()
    // @footer = new_dom_element()


    _createClass(new_alert_msg, [{
      key: "create_header",
      value: function create_header() {
        var _this16 = this;

        this.header = new_dom_element({
          style: {
            width: '100%',
            backgroundColor: "#1a2229",
            color: '#fff'
          }
        });
        this.popup.appendChild(this.header);
        this.title = new_dom_element({
          nodeName: 'span'
        });

        if (this.params.title != null) {
          this.title.innerHTML = this.params.title;
        }

        this.title_close = new_dom_element({
          nodeName: 'span',
          innerHTML: 'x',
          style: {
            display: 'block',
            float: 'right',
            position: 'relative',
            right: '10px',
            cursor: 'pointer'
          },
          onclick: function onclick(evt) {
            if (evt.target !== _this16.title_close) {
              return;
            }

            if (_this16.params.onclose != null) {
              _this16.params.onClose();
            }

            _this16.hide();

            if (typeof evt.stopPropagation === "function") {
              evt.stopPropagation();
            }

            if (typeof evt.preventDefault === "function") {
              evt.preventDefault();
            }

            if (typeof evt.stopImmediatePropagation === "function") {
              evt.stopImmediatePropagation();
            }

            return false;
          }
        });
        this.header.appendChild(this.title);
        return this.header.appendChild(this.title_close);
      }
    }, {
      key: "create_content",
      value: function create_content() {
        this.content = new_dom_element({
          style: {
            width: '100%',
            // backgroundColor: "#FFF"
            color: '#000',
            position: 'relative',
            padding: '15px',
            fontSize: 'xx-large'
          }
        });
        this.popup.appendChild(this.content);
        this.img = new_dom_element({
          nodeName: 'img',
          src: "data:image/gif;base64,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",
          style: {
            height: '35px',
            marginRight: '20px'
          }
        });

        this._loop_spinner_();

        this.content.appendChild(this.img);
        this.msg = new_dom_element({
          nodeName: 'span'
        }); // backgroundColor: "#FFF"
        // color: '#000'
        // position: 'relative'
        // padding: '15px'
        // height: 'calc(100vh - 270px)'
        // overflowY: 'auto'

        return this.content.appendChild(this.msg);
      }
    }, {
      key: "_loop_spinner_",
      value: function _loop_spinner_() {
        if (this.in_rotation === true) {
          return;
        }

        this.in_rotation = true;
        this.deg = this.deg + 360 + 1;
        this.img.style.WebkitTransitionDuration = '2.2s';
        this.img.style.webkitTransform = "rotate(".concat(this.deg, "deg)");
        this.img.style.transitionTimingFunction = 'linear';

        if (this.rotatating === true) {
          return setTimeout(function () {
            this.in_rotation = false;
            return this._loop_spinner_();
          }, 2000);
        } else {
          return this.in_rotation = false;
        }
      }
    }, {
      key: "create_footer",
      value: function create_footer() {
        var b, btn, d, len, q, ref, results;
        this.footer = new_dom_element({
          style: {
            width: '100%',
            // backgroundColor: "#FFF"
            color: '#000',
            position: 'relative',
            padding: '15px',
            height: '100px'
          }
        });
        this.popup.appendChild(this.footer);
        ref = this.params.btn;
        results = [];

        for (q = 0, len = ref.length; q < len; q++) {
          btn = ref[q];
          d = new_dom_element({
            style: {
              width: "".concat(100 / this.params.btn.length, "%"),
              paddingRight: '5px',
              paddingLeft: '5px',
              float: 'left'
            }
          });
          b = new_dom_element({
            nodeName: 'button',
            innerHTML: btn.txt,
            onclick: btn.click,
            style: {
              display: "inline-block",
              padding: "6px 12px",
              marginBottom: "0",
              fontSize: "x-large",
              fontWeight: "400",
              height: '70px',
              lineHeight: "1.42857143",
              textAlign: "center",
              whiteSpace: "nowrap",
              verticalAlign: "middle",
              touchAction: "manipulation",
              cursor: "pointer",
              userSelect: "none",
              border: "1px solid transparent",
              borderRadius: "4px",
              width: "100%",
              backgroundColor: btn.backgroundColor,
              color: "#fff"
            }
          });
          this.footer.appendChild(d);
          results.push(d.appendChild(b));
        }

        return results;
      }
    }, {
      key: "hide_btn",
      value: function hide_btn() {
        this.footer.style.display = 'none';
        return this.img.style.display = 'inline';
      }
    }, {
      key: "show_btn",
      value: function show_btn() {
        this.footer.style.display = 'block';
        return this.img.style.display = 'none';
      }
    }, {
      key: "hide",
      value: function hide() {
        this.background.style.display = 'none';
        return this.rotatating = false;
      }
    }, {
      key: "show",
      value: function show() {
        this.background.style.display = 'block';
        this.rotatating = true;
        return this._loop_spinner_();
      }
    }, {
      key: "setMsg",
      value: function setMsg(msg) {
        return this.msg.innerHTML = msg;
      }
    }]);

    return new_alert_msg;
  }(); // setTile: (msg) ->
  //   @popup.innerHTML = msg
  // make a popup window.
  // returns the creted "inside" div
  // clicking outside closes the window.
  // drag title permits to move he window
  // class names:
  //  - PopupTitle
  //  - PopupWindow
  // Possible params:
  //  - fixed_opacity (for the fixed background)
  //  - fixed_background (for the fixed background)
  //  - width
  //  - height
  //  - event
  //  - child -> child of the main div
  //  - onclose -> callback function


  _index_current_popup = 10000;

  spinal_new_popup = function spinal_new_popup(title) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var _drag_end_func2, _drag_evt_func, b, clientX, clientY, close_element, extention, height, old_x, old_y, repos, res, t, top_x, top_y, w, width;

    if (params.popup_closer == null) {
      b = new_dom_element({
        parentNode: document.body,
        id: "popup_closer",
        onmousedown: function onmousedown() {
          if (typeof params.onclose === "function") {
            params.onclose();
          }

          document.body.removeChild(b);
          return document.body.removeChild(w);
        },
        ondrop: function ondrop(evt) {
          if (!evt) {
            evt = window.event;
          }

          evt.cancelBubble = true;

          if (typeof evt.stopPropagation === "function") {
            evt.stopPropagation();
          }

          if (typeof evt.preventDefault === "function") {
            evt.preventDefault();
          }

          if (typeof evt.stopImmediatePropagation === "function") {
            evt.stopImmediatePropagation();
          }

          return false;
        },
        style: {
          position: "fixed",
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          background: params.fixed_opacity || "#000",
          opacity: params.fixed_opacity || 0,
          zIndex: _index_current_popup
        }
      });
    }

    if (params.event != null && params.event.clientX) {
      //testing clientX to differenciate keyboards event
      clientX = params.event.clientX;
      clientY = params.event.clientY;
    } else {
      clientX = window.innerWidth / 2 - 10;
      clientY = window.innerHeight / 2 - 10;
    }

    top_x = params.top_x || -1000;
    top_y = params.top_y || -1000;
    old_x = 0;
    old_y = 0;
    w = void 0;

    if (params.width != null) {
      width = params.width;
    }

    if (params.height != null) {
      height = params.height;
    } //alert "top: " + top_y + " left: " + top_x + " width: " +  width + " height: " + height


    repos = function repos() {
      top_x = clientX - w.clientWidth / 2;
      top_y = clientY - w.clientHeight / 2;

      if (top_x + w.clientWidth > window.innerWidth) {
        top_x = window.innerWidth - w.clientWidth - 50;
      }

      if (top_y + w.clientHeight > window.innerHeight) {
        top_y = window.innerHeight - w.clientHeight + 50;
      }

      if (top_x < 50) {
        top_x = 50;
      }

      if (top_y < 50) {
        top_y = 50;
      }

      w.style.left = top_x;
      return w.style.top = top_y;
    }; //alert "top: " + top_y + " left: " + top_x + " width: " +  width + " height: " + height


    _drag_evt_func = function _drag_evt_func(evt) {
      top_x += evt.clientX - old_x;
      top_y += evt.clientY - old_y;
      w.style.left = top_x;
      w.style.top = top_y;
      old_x = evt.clientX;
      old_y = evt.clientY;
      return typeof evt.preventDefault === "function" ? evt.preventDefault() : void 0;
    };

    _drag_end_func2 = function _drag_end_func(evt) {
      if (typeof document.detachEvent === "function") {
        document.detachEvent("onmousemove", _drag_evt_func);
      }

      if (typeof document.detachEvent === "function") {
        document.detachEvent("onmouseup", _drag_end_func2);
      }

      if (typeof document.removeEventListener === "function") {
        document.removeEventListener("mousemove", _drag_evt_func, true);
      }

      return typeof document.removeEventListener === "function" ? document.removeEventListener("mouseup", _drag_end_func2, true) : void 0;
    };

    extention = "px";

    if (!params.top_x) {
      setTimeout(repos, 1);
      extention = "%";
    }

    w = new_dom_element({
      parentNode: document.body,
      className: "Popup",
      style: {
        position: "absolute",
        left: top_x,
        top: top_y,
        width: width + extention,
        height: height + extention,
        zIndex: _index_current_popup + 1,
        border: 'thin solid black',
        background: '#e5e5e5',
        resize: 'both',
        overflow: 'auto',
        paddingBottom: '8px'
      }
    });
    _index_current_popup += 2;
    close_element = new_dom_element({
      parentNode: w,
      className: "PopupClose",
      txt: "Close",
      style: {
        float: 'right',
        marginRight: '4px',
        marginTop: '4px',
        cursor: 'pointer'
      },
      onmousedown: function onmousedown(evt) {
        if (typeof params.onclose === "function") {
          params.onclose();
        }

        if (b != null) {
          document.body.removeChild(b);
        }

        return document.body.removeChild(w);
      }
    });

    if (title) {
      t = new_dom_element({
        parentNode: w,
        className: "PopupTitle",
        innerHTML: title,
        style: {
          background: '#262626',
          padding: '5 10 3 10',
          height: '22px',
          fontSize: '12px',
          borderBottom: 'thin solid black',
          cursor: 'pointer',
          color: 'white'
        },
        onmousedown: function onmousedown(evt) {
          old_x = evt.clientX;
          old_y = evt.clientY;
          top_x = parseInt(w.style.left);
          top_y = parseInt(w.style.top);
          document.addEventListener("mousemove", _drag_evt_func, true);
          document.addEventListener("mouseup", _drag_end_func2, true);
          return typeof evt.preventDefault === "function" ? evt.preventDefault() : void 0;
        }
      });
    }

    res = new_dom_element({
      parentNode: w,
      className: "PopupWindow",
      style: {
        padding: "6px",
        height: '100%',
        color: '#262626'
      }
    });

    if (params.child != null) {
      res.appendChild(params.child);
    }

    return res;
  };
}).call(this);
